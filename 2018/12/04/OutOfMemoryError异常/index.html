<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OutOfMemoryError异常 · 你以为</title><meta name="description" content="OutOfMemoryError异常 - 你以为"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="你以为"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="https://github.com/niyiwei" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OutOfMemoryError异常</h1><div class="post-info">2018年12月4日</div><div class="post-content"><p>在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfmemoryError(OOM)异常的可能</p>
<a id="more"></a>
<h1 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h1><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在对象数量达到最大堆的容量限制后就会产生内存溢出异常。</p>
<p>参数:</p>
<ol>
<li>-Xms20m (将堆的最小值)</li>
<li>-Xmx20m (堆的最大值)</li>
<li>-XX:+HeapDumpOnOutOfMemoryError (让虚拟机在内存溢出异常时Dump出当前内存堆转储快照以便事后进行分析)</li>
</ol>
<p>当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError” 会跟着进一步提示 “Java heap space”。</p>
<p>要解决这个区域的异常，一般的手段实现通过内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Lock）还是内存溢出（Memory Overflow）。</p>
<h1 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h1><p>由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数(设置本地方法栈大小)存在，但实际是无效的，栈容量只由-Xss参数设定。</p>
<p>在Java虚拟机规范中描述了两种异常</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li>
</ul>
<h1 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h1><p>参数：</p>
<ul>
<li>-XX:PermSize 方法区大小</li>
<li>-XX:MaxPermSize 方法区最大值</li>
</ul>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<h1 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h1><p>DirectMemory 容量可通过 -XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值(-Xmx指定)一样。</p>
<p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO,那就可以考虑检查一下是不是这方面的原因。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/12/04/垃圾收集器与内存分配策略/" class="prev">上一篇</a><a href="/2018/11/29/Java内存区域与内存溢出异常/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">你以为</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>