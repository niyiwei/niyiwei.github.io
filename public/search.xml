<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库系统原理 - SQL与关系数据库基本操作]]></title>
    <url>%2F2018%2F08%2F27%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第四章 - SQL与关系数据库基本操作SQL概述什么是SQL结构化查询语言 （Structured Query Language，SQL）是专门用来与数据库通信的语言，它可以帮助用户操作关系数据库 SQL的特点 SQL不是某个特定数据库供应商专用的语言 SQL简单易学 SQL强大、灵活，可以进行非常复杂和高级的数据库操作 SQL的组成 数据查询 数据定义 数据操纵 数据控制 数据定义语言（Date Definition Language，DDL） CREATE 创建数据库或数据库对象 ALTER 对数据库或数据库对象进行修改 DROP 删除数据库或数据库对象 数据库操纵语言（Date Manipulation Language，DML） SELECT 从表或视图中检索数据 INSERT 将数据插入到表或视图中 UPDATE 修改表或视图中的数据 DELETE 从表或视图中删除数据 数据控制语言（Data Control Language，DCL） GRANT 用于授予权限 REVOKE 用于收回权限 嵌入式和动态SQL规则 规定SQL语句在高级程序设计语言中使用的规范方法，以便适应较为复杂的应用 SQL调用和会话规则 SQL调用包括SQL例程和调用规则，以便提高SQL的灵活性、有效性、共享性以及使SQL具有更多的高级语言的特征； SQL会话规则可使应用程序连接到多个SQL的服务器中的某一个，并与之交互。 MySQL预备知识MySQL使用基础关系数据库管理系统（ RDBMS ） LAMP - （Linux Apache MySQL PHP/Perl/Python） WAMP - (Windows Apache MySQL PHP/Perl/Python) MySQL扩展语言要素 常量 字符串常量（也称字面值或标量值） 用单引号或双引号括起来的字符序列，分为ASCLL字符串常量和Unicode字符串常量 数值常量 整数常量 浮点数常量 十六进制常量（每对十六进制数字被转换为一个字符，其最前面有一个字母’X’或“x”） 时间日期常量（用单引号讲表示日期时间的字符串括起来而构成的） 位字段值 格式：b’value’ -&gt; 二进制值 布尔值 TURE -&gt; 1, FALSE -&gt; 0 NULL值 变量 用户变量 用户变量前常添加一个符号@，用于将其与列名区分开 系统变量 大多数系统变量应用于其他SQL语句中时，必须在系统变量前添加两个@ 运算符 算数运算符：+（加），-（减），*（乘），/（除），%（求模） 位运算符：&amp;（位于），|（位或），^（位异或），~（位取反），&gt;&gt;（位右移），&lt;&lt;（位左移） 比较运算符：=，&lt;，&gt;，&gt;=，&lt;=，&lt;&gt;，!=，&lt;=&gt; 逻辑运算符：NOT或！（逻辑非），AND或%%（逻辑与），OR或||（逻辑或），XOR（逻辑异常） 表达式 表达式是常量、变量、列名、复杂计算、运算符和函数的组合 内置函数 数学函数 聚合函数 字符串函数 日期和时间函数 加密函数 控制流程函数 格式化函数 类型转换函数 系统信息函数### 数据定义数据库模式定义####创建数据库使用 CRESTE DATABASE 或 CREATE SCHEMA 语句 语法：123CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name[DEFAULT] CHARACTER SET[=]charset_name|[DEFAULT]COLLATE[=]collation_name 栗子：12mysql&gt; create database if not exists mysql_test default character set = gbk;Query OK, 1 row affected (0.00 sec) []：表示其内容为可选项；|： 用于分割花括号中的选项 选择数据库语法：1USE DATABASE_NAME; 栗子：12mysql&gt; USE mysql_test;Database changed 修改数据库语法：12ALTER &#123;DATABASE|SCHEMA&#125; [db_name]alter_specification... 栗子：1234mysql&gt; ALTER DATABASE mysql_test -&gt; DEFAULT CHARACTER SET gb2312 -&gt; DEFAULT COLLATE gb2312_chinese_ci;Query OK, 1 row affected (0.00 sec) 删除数据库语法:1DROP &#123;DATABASE|SCHEMA&#125; [IF EXISTS] [db_name] 栗子:12mysql&gt; DROP DATABASE IF EXISTS mysql_test;Query OK, 0 rows affected, 1 warning (0.00 sec) 查看数据库语法：12SHOW &#123;DATABASES|SCHEMA&#125;[LIKE &apos;pattern&apos; | WHERE expr] LIKE 关键字用于匹配指定的数据库名称 WHERE 从句用于指定数据库名称查询范围的条件 栗子：123456789101112ysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || mysql_test || performance_schema || study || sys |+--------------------+6 rows in set (0.00 sec) 表定义创建表数据表示关系数据库中最重要的、最基本的数据对象，也是数据存储的基本单位 数据表，被定义为字段的集合，按行和列的格式来存储的，每一行代表一个记录，每一列代表记录中一个字段的取值 CREATE TABLE 语句创建表 主要由： 表创建定义（create definition） 表选项：（table options） 分区选项：（partition options） 语法：123456CREATE [TEMPORARY] TABLE tbl_name( 字段名1 数据类型 [列级完整性约束条件][默认值] [,字段名2 数据类型 [列级完整性约束条件][默认值]] [,表级完整性约束])[ENGINT=引擎类型] 栗子：在一个已有的数据库mysql_test中新建一个包含客户姓名、性别、地址、联系方式等内容的客户基本信息表，要求将客户的id号指定为该表的主键12345678910mysql&gt; CREATE TABLE customers -&gt; ( -&gt; cust_id int not null auto_increment -&gt; ,cust_name varchar(50) not null -&gt; ,cust_sex char(1) not null -&gt; ,cust_address char(50) null -&gt; ,cust_contact char(50) null -&gt; ,primary key (cust_id) -&gt; );Query OK, 0 rows affected (0.05 sec) 更新表使用ALTER TABLE语句，增加或删减列，创建或取消索引，更改原有列的数据类型，重新命名列或表，更改表的评注和表达引擎类型，为表重新创建触发器、存储过程、索引和外建等。 ADD[COLUMN]子句 示例：想数据库mysql_test的表customers中添加一列，并命名为cust_city,要求不能为null，默认值为字符串”Wuhan”,且该列位于原表cust_sex列之后。 语法:12ALTER TABLE mysql_test.customersADD COLUMN cust_city char(10) NOT NULL DEFAULT &apos;Wuhan&apos; AFTER cust_sex; 栗子：123mysql&gt; ALTER TABLE mysql_test.customers ADD COLUMN cust_city char(10) NOT NULL DEFAULT &apos;Wuhan&apos; AFTER cust_sex;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0 CHANGE[COLUMN]子句 (修改表中列的名称或数据类型) 语法：12ALTER TABLE mysql.test.customersCHANGE COLUMN cust_sex sex char(1) NULL DEFULT &apos;M&apos;; 栗子:1234mysql&gt; ALTER TABLE mysql_test.customers -&gt; CHANGE COLUMN cust_sex sex char(2) NULL DEFAULT &apos;M&apos;;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 ALTER[COLUMN]子句 修改或删除表中指定列的默认值 语法：12ALTER TABLE mysql_test.customersALTER COLUMN cust_city SET DEFAULT &apos;Beijing&apos;; 栗子：123mysql&gt; ALTER TABlE mysql_test.customers ALTER COLUMN cust_city SET DEFAULT &apos;Beijing&apos;;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 MODIFY[COLUMN]子句 只修改指定列的数据类型，不会干涉它的列名语法：12ALTER TABLE mysql_test.customersMODIFY COLUMN cust_name char(20) FIRST; 栗子:1234mysql&gt; ALTER TABLE mysql_test.customers -&gt; MODIFY COLUMN cust_name char(11) not null AFTER cust_id;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 DROP[COLUMN]子句 删除列语法： 123mysql&gt; ALTER TABLE mysql_test.customers DROP COLUMN cust_contact;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 RENAME[TO]子句 更新表名 语法:12ALTER TABLE mysql_test.customersRENAME TO my_customers; 栗子：123mysql&gt; ALTER TABLE mysql_test.customers -&gt; RENAME TO backup_customers;Query OK, 0 rows affected (0.00 sec) 删除表语法:1DROP[TEMPORANY] TABLE [IF EXISTS] tb_name [,tb_name] 栗子：12mysql&gt; DROP TABLE IF EXISTS backup_customers;Query OK, 0 rows affected (0.01 sec) 查看表语法：1SHOW [FULL] COLUMN &#123;FROM | IN&#125; tbl_name [&#123;FROM | IN&#125; db_name] [LIKE &apos;pattern&apos; | WHERE expr] 显示指定数据表的结构1&#123;DESCRIBE | DESC&#125; tbl_name [col_name | wild] 栗子： 索引定义索引是DBMS根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表 索引是提高数据文件访问效率的有效方法 索引存在的弊端： 索引是以文件的形式存储的，如果有大量的索引，索引文件可能比数据更快达到最大的文件尺寸 索引在提高查询速度的同时，会降低更新表的速度 普通索引（INDX或KEY） 唯一性索引(UNIQUE) 主键(PRIMARY KEY) 索引通常被创建成单列索引和组合索引 索引的创建：（使用CREATE INDEX语句创建）语法：12CREATE [UNIQUE] INDEX index_name ON tbl_name(index_col_name...) col_name[(length)][ASC|DESC] 栗子：123mysql&gt; CREATE INDEX index_customers -&gt; ON mysql_test.customers(cust_name(3) ASC);Query OK, 0 rows affected (0.02 sec) 组合索引栗子：12mysql&gt; CREATE INDEX index_cust -&gt; ON mysql_test.customers(cust_name, cust_id); 索引的创建：使用 CREATE TABLE 语法创建 语法项 [CONSTRAINT[symbol]] PRIMARY KEY(index_col_name, …),用于表示在创建新表的同时创建该表的主键； 语法项 {INDEX|KEY}index_name,用于表示在创建新表的同时创建该表的索引； 语法项 [CONSTRAINT[symbol]]UNIQUE[INDEX|KEY]index_name 用于表示在创建新表的同时创建该表的唯一性索引 语法项 [CONSTRAINT[symbol]] FOREIGN KEY index_name,用于表示在创建新表的同时创建该表的外建 栗子:123456789101112mysql&gt; create table seller -&gt; ( -&gt; seller_id int not null auto_increment -&gt; ,seller_name char(50) not null -&gt; ,seller_address char(50) null -&gt; ,seller_contact char(50) null -&gt; ,product_type int(5) not null -&gt; ,sales int null -&gt; ,primary key(seller_id, product_type) -&gt; ,index index_seller(sales) -&gt; );Query OK, 0 rows affected (0.02 sec) 索引的创建：使用ALTER TABLE语句创建 语法项：ADD {INDEX | KEY} index_name, 用于表示在修改表的同时为该表添加索引 语法项：ADD [CONSTRAINT [symbol]] PRIMARY KEY (index_col_name,…), 用于表示在创建新表的同时为该表添加主键 语法项：ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]index_name,用于表示在修改表的同时为该表添加唯一性索引 语法项：ADD [CONSTRAINT [symbol]] FOREIGN KEY (index_col_name,…),用于表示在创建新表的同时为该表添加外建 查看索引（SHOW INDEX）语法：1234SHOW &#123;INDEX | INDEXES | KEYS&#125;&#123;FROM | IN&#125; tbl_name[&#123;FROM | IN&#125; db_name][WHERE expr] 栗子：123456789mysql&gt; show index from seller;+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| seller | 0 | PRIMARY | 1 | seller_id | A | 0 | NULL | NULL | | BTREE | | || seller | 0 | PRIMARY | 2 | product_type | A | 0 | NULL | NULL | | BTREE | | || seller | 1 | index_seller | 1 | sales | A | 0 | NULL | NULL | YES | BTREE | | |+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.00 sec) 删除索引：使用DROP INDEX语句语法：1DROP INDEX index_cust ON mysql_test.customers; 栗子：12mysql&gt; drop index index_cust ON customers;Query OK, 0 rows affected (0.02 sec) 使用ALTER TABLE语句删除 选用 DROP PRIMARY KEY 子句用于删除表中的主键，由于一个表中只有一个主键，其也是一个索引 选用DROP INDEX子句用于删除各种类型的索引 选用DROP FOREIGN KEY 子句用于删除外建 栗子:1234ALTER TABLE T_NAMEDROP PRIMARY KEY,DROP INDEX INDEX_NAME,DROP FOREIGN KEY 数据更新插入数据语法:12INSERT [INSERT] tbl_name [(col_name,...)]&#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,...),(...)... 栗子：12mysql&gt; insert into customers(cust_id, cust_name, cust_sex, cust_address, cust_contact) values (901, &apos;张三&apos;, &apos;F&apos;, &apos;北京市&apos;, &apos;朝阳区&apos;);Query OK, 1 row affected (0.02 sec) 使用INSERT … SET 语句插入部分列值数据 使用INSERT …SELECT语句插入子查询数据 删除数据使用DELETE语句删除一行或多行数据 修改数据使用UPDATE语句修改更新一个表中的数据 数据查询SELECT语句语法：123456789SELECT [ALL | DISTINCT | DISTINCTROW]select_expr [, select_expr ...]FROM tbl_name[WHERE where_condition][GROUP BY &#123;col_name|expr|position&#125;[ASC|DESC],...[WITH ROLLUP]][HAVING where_condition][ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC],...][LIMIT &#123;[offset,]row_count | row_count OFFSET offset] 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚合时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的函数 否 列的选择与指定 查询指定列 SELECT col_name1,col_name2 FROM tbl_name 查询所有列 SELECT * FROM tbl_name 定义并使用列的别名 SELECT cust_name as 地址 from customers; 替换查询结果集中的数据 123456CASE WHEN 条件1 THEN 表达式1 WHEN 条件2 THEN 表达式2....ELSE 表达式END [AS] column_alias 例:123456mysql&gt; SELECT cust_name, CASE WHEN cust_sex = &apos;m&apos; THEN &apos;男&apos; ELSE &apos;女&apos; END AS 性别 FROM customers;+-----------+--------+| cust_name | 性别 |+-----------+--------+| 哇哈哈 | 男 |+-----------+--------+ 计算列值123456mysql&gt; SELECT cust_id + 100, cust_name, cust_sex FROM customers;+---------------+-----------+----------+| cust_id + 100 | cust_name | cust_sex |+---------------+-----------+----------+| 101 | 哇哈哈 | m |+---------------+-----------+----------+ 聚合函数：通常是数据库系统中一类系统 内置函数|函数名|说明||:–|:–||COUNT|求组中项数，返回INT类型整数||MAX|求最大值||MIN|求最小值||SUM|返回表达式中所有值的和||AVG|求组中值的平均值||STD或STDDEV|返回给定表达式中所有值的标准值||VARIANC|返回给定表达式中所有值的方差||GROUP_CONTACT|返回由属于一组的列值连接组合而成的结果||BIT_AND|逻辑或||BIR_OR|逻辑与||BIT_XOR|逻辑异或| FROM子句与多表连接查询交叉连接，又称笛卡尔积语法：123SELECT * FROM tbl1 CROSS JOIN tbl2;ORSELECT * FROM tbl1, tbl2; 栗子：12mysql&gt; select * from tbl1 cross join tbl2;mysql&gt; select * from tbl1,tbl2; 内连接语法1SELECT some_columns FROM table1 INNER JOIN table2 ON some_conditions; 栗子:12 等值连接：使用运算符= 非等值连接：使用除=之外的其他比较运算符 自然连接：将一个表与他自身进行连接 外链接 左外链接：在FROM子句中使用关键字LEFT OUTER JOIN 或 LEFT JOIN 右外链接：在FROM子句中使用关键字RIGHT OUTER JOIN 或 RIGHT JOIN 简述左外连接和右外连接的区别 左外链接：也称左连接。以左表为基表，在FROM子中使用关键字“LEFT OUTER JOIN”或关键字 “LEFT JOIN” 来连接两张表。右外连接：也称右连接。以右表为基表，在FROM子句中使用关键字“RIGHT OUTER JOIN”或关键字“RIGHT JOIN”来连接两张表 WHERE子句与条件查询比较运算符 比较运算符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 &lt;=&gt; 不会返回UNKNOWN 判断范围 当查询的过滤条件被限定在值的某个范围时，可以使用关键字“BETWEEN”语法：1SELECT * FROM customers WHERE cust_id BETWEEN 1 AND 2; 使用关键字“IN”可以指定一个值的枚举表，该表中会列举所有可能的值语法：1SELECT * FRON customers WHERE cust_id in (1,2,3,4,5); 判定空值语法：1SELECT * FROM customers WHERE cust_contact is null; IN,ANY,SOME NOT IN , &lt;&gt;ALL 1SELECT * FROM tb_name WHERE col_name &#123;IN|ANY|SOME&#125; (1,2,3) 子查询-结合关键字 “EXIST”使用的子查询 子查询的结果集不为空，则返回TRUE，否则返回FALSE123SELECT * FROM customers WHERE EXISTS (SELECT * FROM customers);SELECT * FROM customers WHERE NOT EXISTS (SELECT * FROM customers); GROUP BY 子句1SELECT * FROM customers GROUP BY &#123;col_name | position&#125;[ASC | DESC],...[WITH ROLLUP] 指定在结果集中不仅包含由GROUP BY 子句分组后的数据行，还包括各分组的汇总行，以及所有分组的整行汇总行，可以得到每个分组以及每个分组汇总级别的值 HAVING 子句1HAVING WHERE_COINDITION HAVING子句 WHERE子句 过滤分组 过滤数据行 可以包含聚合函数 不可以包含聚合函数 在数据分组后进行过滤 在数据分组前过滤 ORDER BY 子句1ORDER BY &#123;col_nae expr | position&#125;[AC | DESC],... ORDER BY GROUP BY 排序产生的输出 分组行，但输出可能不是分组的排序 任意列都可以使用 只可能使用选择列或表达式 不一定需要 若聚合函数一起使用列或表达式，则必须使用 LIMIT子句使用LIMIT子句限制被SELECT语句返回的行数1LIMIT &#123;[offset,] row_count | row_count OFFSET OFFSET&#125; 栗子：123SELECT * FROM customers LIMIT 1,2;SELECT * FROM customers 2 OFFSET 1; 视图什么是视图视图是数据库中的一个对象，它是数据库管理系统提供给用户的以多种角度观察数据库中数据的一种重要机制 视图不是数据库中真实的表，而是一张虚拟表，其自身并不存在 使用视图的优点 集中分散数据 简化查询语句 重用SQL语句 保护数据安全 共享所需数据 更改数据格式创建视图123CREATEVIEW view_name[(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 指定在可更新视图上所进行的修改都需要复符合select_statement中所指定的限制条件 删除视图1drop view [if exists] view_name [,view_name]... 修改视图定义123ALTERVIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 查看视图定义1SHOW CREATE VIEW view_name 更新视图数据1INSERT INTO customers_view VALUES (NULL, &apos;农夫山泉&apos;, &apos;m&apos;, &apos;北京&apos;, &apos;有点甜&apos;); 使用UPDATE语句通过视图修改基本表的数据1UPDATE customers_view SET cust_address = &apos;湖北&apos; WHERE cust_name = &apos;农夫山泉&apos;; 使用DELETE语句通过视图删除基本表的数据1DELETE FROM customers_view WHERE cust_name = &apos;农夫山泉&apos;; 查询数据视图12SELECT * FROM customers_view;`]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库管理系统-第三章-数据库设计]]></title>
    <url>%2F2018%2F08%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[数据库设计数据库设计概述数据库的生命周期 数据库分析与设计阶段 需求分析 概念设计 逻辑设计 物理设计 数据库实现与操作阶段 实现 操作与监督 修改与调整 数据库设计的目标 满足应用功能需求（存、取、删、改） 良好的性能（共享性，完整性，一致性，安全保密性） 数据库设计的内容 数据库结构设计（结构-静态的） 数据库概念结构设计 逻辑结构设计 物理结构设计 数据库行为设计（操作-动态的） 功能设计 事物设计 程序设计 数据库设计的方法 直观设计法（最原始的数据库设计方法） 规范设计法 新奥尔良设计方法：需求分析、概念结构设计、逻辑结构设计、物理结构设计 基于E-R模型的数据库设计方法 基于第三范式的设计方法，是一类结构化设计方法 计算机辅助设计法 数据库设计的过程 需求分析 结构设计 行为设计 数据库实施 加载数据库数据 调试运行应用程序 数据库运行与维护 数据设计的基本步骤需求分析目标：是了解与分析用户的信息及应用处理的需求，并将结果按一定格式整理而形成需求分析报告 该分析报告是后续 概念设计，逻辑设计，物理设计，数据库建立与维护的依据 步骤： 确定数据的范围 支持哪些应用功能 有效地利用计算机设备及数数据库系统的潜在能力 提高数据的应变能力 避免应用过程中对数据库做太多或太大的修改 延长数据库的生命周期 分析数据应用过程-结果是数据库设计结构设计的重要依据 用到哪些数据 数据使用的顺序 对数据作何处理和处理的策略以及结果 收集与分析数据 数据分类表-用于数据的总体描述（静态的结构） 数据元素表-值通常意义下的数据项或属性（静态结构） 任务分类表-一个任务指为完成某个特定处理功能的相对独立的操作序列（动态结构） 数据特征操作表-用以描述任务和数据之间的关系，它包括不同任务对数据执行不同操作的评率（动态） 数据约束 数据的安全保密性 数据的完整性 响应时间 数据恢复 编写需求分析报告 数据的应用功能目标 标明不同用户视图范围 应用处理过程需求说明，包括，数据流程图；任务分类表；数据操作特征表；操作过程说明书。 数据字典，是数据系统中存储三级结构定义的数据库，通常指的是数据库系统中各类数据详细描述的集合。通常包括数据分类表、数据元素表和各类原始资料 数据量 数据约束 概念结构设计 概念模型（自顶向下） 顶层设计 独立于任何软件与硬件 主要目标：最大限度的满足应用需求 逻辑结构设计 层次模型 网状模型 关系模型 面向对象模型 概念设计 –&gt; 模型转换 –&gt; 子模式设计 / 应用程序设计说明 –&gt; 设计评价(检验) –&gt; 物理设计 物理设计具体任务主要是确定数据在存储设备上的 存储结构 及 存取方法 ，因DBMS的不同还可能包括 建立索引 和 聚集，以及 物理块的大小、 缓冲区个数和大小、数据压缩的选择 数据库实施 加载数据：收集、分类、整理校验、输入等 应用程序设计：具有较高的稳定性，并具有试运行的数据基础，也具备了应用程序编制与调试的必要条件。这样编写的应用程序具有较高的稳定性和实用性 数据库试运行 有利于工作人员掌握并熟悉系统 有利于正式运行时避免人为的的操作不当等损害 数据库运行与维护需求分析– 结构设计 / 行为分析 – 数据实施 – 数据库运行与维护 保证数据库的正常运行 系统维护中最困难的工作是 数据库重组与重构 关系数据库设计方法关系数据库设计过程与各级模式应用要求 – 概念模式（E-R图） – 逻辑模式 –内模式 概念结构设计方法E-R图的表示方法1：1 的联系1：N 的联系M：N 的联系单个实体型内的一对多联系 局部信息结构设计： 确定局部范围：局部范围主要依据需求分析报告中标明的用户视图范围来确定。往往与子模式范围相对应 选择实体：数据分类表是选择实体的直接依据，实体选择最大困难时如何区别 实体与属性 选择实体的关键字属性：实体的存在依赖于其 关键字 的存在 确定实体间的联系：数据间的联系必须在概念设计时确定 确定实体的属性：属性分为标识属性和说明属性 全局信息结构设计： 逻辑结构设计方法 将E-R图转化为关系模式 一个实体型转换为一个关系模式，实体的属性作为关系的属性，实体的码作为关系的码 一个一对一联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并 一个一对多联系可以转换为一个独立的关系模式，也可以与N端对应的关系模式合并 一个对多对联系转换为一个关系模式 三个或以上实体间的一个多元联系可以转换为一个关系模式 具有相同码的关系模式可合并 对关系数据模型进行优化 数据逻辑设计的结果，不是唯一的 进一步提高数据库应用系统的性能 根据需要适当地修改、调整数据模型的结构 数据模型的优化 确定各属性间的函数依赖关系 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系 判断每个关系模式的范式，根据实际需要确定最合适的范式 按照需求分析阶段得到的处理要求，分析这些模式对于这样的应用环境是否合适，确定是否要对某些模式进行合并或分解 对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率 设计面向用户的外模式（子模式） 可以通过试图机制在设计使用户视图时，重新定义某些属性的别名，使其更符合用户的习惯，以方便使用 可以对不同级别的用户定义不同的视图，以保证系统的安全性 简化用户对系统的使用 物理设计 建立索引（逻辑连接） 静态建立索引 动态建立索引 建立聚集（物理聚集） 聚集是将相关数据集中存放 的物理存储技术 数据聚集结构的一种有效方式是 块结构方式 数据聚集可在 一个或多个关系上建立]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第二章 · 关系数据库]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第二章 · 关系数据库 关系数据库概述 关系数据模型 关系数据库的规范化理论（范式） 2.1 关系数据库概述关系数据库的产生历史 1970年 IBM的E.F.Codd提出了关系模型，奠定了关系数据库的理论基础 20世纪70年代末 关系方法理论研究和软件系统的研制取得了重大突破 1981年 出现了比较成熟的关系数据库管理技术，证实了关系数据库的优点 高级的非过程语言接口、较好的数据独立性 20世纪80年代后 网状模型和层次模型与低层实现的结合紧密，关系模型具有坚实理论基础，称成为主流数据模型 2.2 关系数据模型组成要素 关系数据结构 关系操作集合 关系完整性约束 关系数据结构 表（Table）是一个二维的数据结构，由表名、列、若干行数据组成 关系（Relation）一个关系逻辑上对应一张二维表，可以为每个关系去一个名称进行表示 基本关系（基本关系表、基表） 查询表 视图表 列（Column）也称字段（Field）或属性（Attribute） 表名必须唯一 字段名必须唯一 不同表中可以出现相同的字段名 属性（Attribute）= 列 行（Row）也成为 元组（Tuple） 或 记录（Record）。表中的数据按行存储 分量（Component）= 具体的数据项 元组（行）中的一个属性值，称为分量 码或键（Key） 属性（或属性组）的值 都能用来 唯一表示该关系的元组，则称这些属性（或属性组）为该关系的码或键 超码或超键（Super Key） 在码中去除某个属性，它仍然是这个关系的码 候选码或候选键（Candidate Key） 在码中不能从中移去任何一个属性，否则它就不再是这个关系的码或键。候选码或候选键是这个关系的最小超码或超键 主属性（Primary Attribute）或非主属性（NonPrimanry Attribute） 包含在任何一个候选码中的属性称为主属性或码属性 主码或主键（Primary Key）主观意愿指定的 在若干个候选码中指定一个唯一标识关系的元组（行） 全码或全键（All Key） 一个关系模式的所有属性集合是这个关系的主码或主键，这样主码或主键称为全码或全键 外码或外键（Foreign Key） 某个属性（或属性组）不是这个关系的主码或候选码，而是另一个关系的主码 域（Domain）表示属性的取值范围 数据类型（Date Type） 每个列都有相应的数据类型，它用于限制（或容许）该列中存储的数据 关系模式（Relation Schema） 关系模型是型（type），关系是值（value），即关系模式是对关系的描述 关系模式是静态的、稳定的 关系是动态的，随时间不断变化的 关系数据库（Relation Database） 所有关系的集合，构成了一个关系数据库 以关系的集合，构成一个关系数据库。 以关系模型作为数据的逻辑模型，并采用关系作为数据的组织方式的一类数据库，其数据操作建立在关系代数的基础上 关系数据库对关系的限定/要求： 每个属性都是不可分解的（不允许表中有表） 每个关系仅仅有一种关系模式 每一个关系模式中的属性必须命名，属性名不同 同一个关系中不允许出现候选码或候选键值完全相同的元组 在关系中元组的顺序（即行序）是无关紧要的，可以任意交换 在关系中属性的顺序（即列序）是无关紧要的，可以任意交换 基本的关系操作 查询（Query） 选择 投影 并 差 笛卡尔积 由上述的操作引出 连接、除、交 插入（Insert） 修改（Delete） 删除（Update） 特点：集合操作方法（一次一集合） 关系数据语言 关系代数语言 SQL 关系演算语言 元组关系演算 域关系演算 运算符任何一种操作都包含三大要素： 操作对象 操作符 集合运算符 关系运算符 比较操作符 逻辑操作符 操作结果 传统的集合运算符 并（UNION） R3 = R1 ∪ R2 两个关系必须有相同的属性个数 差（DIFFERENCE）R3 = R1 - R2 两个关系必须有相同的属性个数 交（INTERSECTION）R3 = R1 ∩ R2 两个关系必须有相同的属性个数 笛卡尔积（CARTESIAN PRODUCT）R3 = R1 × R3 两个关系可以由不相同的属性个数 专门的关系运算选择（SELECT）：Of(R) SELECT 关系名 WHERE 条件由常数、属性名或列名、比较操作符（&gt;、&lt;、=、≥、≤、≠）及逻辑操作符（）组成的条件表达式 投影（PROJECTION）πA（R） PROJECTION 关系名（属性名1，属性名2，…，属性名n） 连接（JOIN） JOIN 关系名1 AND 关系名2 WHERE 条件1、笛卡尔积2、只留属性值相同3、去掉重复列 除（DIVISION）：R ÷ S 1、投影2、笛卡尔积3、全部相同4、得出除表 完整性约束数据库的完整性是值数据库中数据的 正确性、相容性、一致性 分类： 实体完整性约束（Entity Integrity Constraint）主码的组成不能为空，主属性不能是空值NULL 参照完整性约束（Referential Integrity Constraint）定义外码和主码之间的引用规则，要么外码等于主码中某个元组的主码值，要么Null值 用户定义完整性约束（User-defined Integrity Constraint）域完整性约束（针对某一应用环境的完整性约束），其他 执行插入操作的检验 检查实体完整性约束 检查参照完整性约束 检查用户定义完整性约束 执行删除操作 (是否被引用) 一般只需要对被参照关系检查参照完整性约束 执行更新操作上述两种情况的综合 关系数据库的规范化理论 关系模式中可能存在的冗余和异常问题 函数依赖于关键字 范式于关系规范化过程 关系模式中可能存在的冗余和异常问题数据冗余：指同一数据被反复存储的情况 更新异常：数据冗余造成的 插入异常： 删除异常： 函数依赖于关键字什么是函数？ f: a –&gt; B, y=f(x) 分类： 完全函数规范设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的任何真子集X丿，都有 X丿 依赖 Y，则称Y完全函数依赖于X例：X 表 A,B属性 组成 R，并且 X 依赖 Y，且对X中的任何真子集 部分函数依赖设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的存在一个真子集X丿，满足 X丿 依赖 Y，则称Y部分函数依赖于X 传递函数依赖设R为任一给定关系， X,Y,Z为其不同属性子集，若 X 依赖 Y， Y 不依赖 X， Y 依赖 Z， 则有 X 依赖 Z，称为Z传递函数依赖于X 关键字设R为任一给定关系，U为其所含的全部属性集合 X为U的子集，若有完全函数以为 X依赖U，则X为R的一个候选关键字 范式与关系规范化过程一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合，这个过程就叫 规范化（Normalization） 第一范式1NF设R为任意给定关系，若果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式 第二范式设R为任意给定关系，若R为1NF，且其所有非主属性都完全含糊依赖于候选关键字，则R为第二范式 第三范式设R为任意给定关系，若R为2NF，且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式 第三范式的改进形式BCNF设R为任一给定关系，X,Y为其属性集，F为函数依赖集，若R为3NF，且其F中所有函数依赖 X -&gt; Y(Y不属于X)中的X必包含候选关键字，则R为BCNF。]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[检索数据]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[介绍如何使用SELECT语句从表中检索一个或多个数据列。 1、SELECT语句&nbsp;&nbsp;&nbsp;&nbsp;SQL语句由简单的英语单词构成。这些英语单词称为关键字，每个SQL语句都是用一个或多个关键字构成的。 2、检索单个列输入 SELECT prod_name FROM products;分析: 利用SELECT语句从product表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。 SQL语句和大小写 SQL语句不区分大小写，因此SELECT与select是相同的。许多开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。使用空格 在处理SQL语句时，其中所有空格都被忽略。SQL语句可以在一行上给出，也可以分成许多行。多行易于调试。 3、检索多个列&nbsp;&nbsp;&nbsp;&nbsp;要想从一个表中检索多个列，使用相同的SELECT语句。唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须有逗号分隔。 当心逗号 在选择多个列时，一定要在列名之间加上逗号，但最后一个列名不加。 例：SELECT prod_id, prod_name, prod_price FROM products; 4、检索所有列&nbsp;&nbsp;&nbsp;&nbsp;除了指定所需的列外，SELECT语句还可以检索所有的列而不必逐个列出它们。这可以通过在实际列名的位置使用星号（）通配符来达到。例：`SELECT FROM products;` 使用通配符 一般，除非你确实需要表中的每个列，否则最好别使用*通配符。检索不需要的列通常会降低检索和应用程序的性能。 5、检索不同的行&nbsp;&nbsp;&nbsp;&nbsp;SELECT返回所有匹配的行。但是，如果你不想要每个值都出现，怎么办? 使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。例：SELECT DISTINCT vend_id FROM products; 不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price, 除非指定的两个列都不同，否则所有行都将被检索出来。 6、限制结果&nbsp;&nbsp;&nbsp;&nbsp;SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句。 例: SELECT prod_name FROM products LIMIT 5;次语句使用SELECT语句检索单个列。 LIMIT 5指示MySQL返回不多于5行。 为了得出下一个5行，可指定要检索的开始行和行数。 例：SELECT prod_name FROM products LIMIT 5,5; 分析：LIMIT 5,5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数 行0 检索出来的第一行为行0而不是行1。因此， LIMIT 1,1将检索出第二行而不是第一行。在行数不够时 LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行，MySQL将只返回的那么多行。MySQL 5的LIMIT语法 LIMIT 3,4的含义是从行3开始的4行，这容易把人搞糊涂，MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意从行3开始取4行，就像LIMIT 3,4一行。 7、使用完全限定的表名例：SELECT products.prod_name FROM products; 表名也是可以完全限定的 例：SELECT products.prod_name FROM crashcourse.products;]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用MySQL]]></title>
    <url>%2F2018%2F08%2F02%2F%E4%BD%BF%E7%94%A8MySQL%2F</url>
    <content type="text"><![CDATA[1、连接为了连接到MySQL，需要以下信息： 主机名（计算机名）– 如果连接到本地MySQL服务器，为localhost； 端口（如果使用默认端口3306之外的端口） 一个合法的用户名； 用户口令 示例：1mysql -u ben -p -h myserver -P 9999 2、选择数据库在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作之前，需要选择一个数据库。为此，可使用 USE 关键字 关键字（key word）作为MySQL语言组成部分的一个保留字。绝不要用关键字命名一个表或列 示例：1USE crashcourse; 3、了解数据库和表&nbsp;&nbsp;&nbsp;&nbsp;数据库、表、列、用户、权限等的信息被存储在数据库和表中。如果不知道可以使用的数据库名时，可以使用 MySQL的 SHOW 命令来显示这些信息。 示例：1SHOW DATABASES; 为了获取一个数据库内的表的列表，使用 SHOW TABLES;示例：1SHOW TABLES; SHOW 也可以用来显示表列 SHOW COLUMNS FROM customers;DESCRIBE 语句 MySQL支持功DESCRIBE作为SHOW COLUMNS FROM的一种快捷方式。换句话说，DESCRIBE customers; 是SHOW COLUMNS FROM customers;的一种快捷方式。 所支持的其他 SHOW 语句还有： SHOW STATUS; 用于显示广泛的服务器状态信息； SHOW CREATE DATABASE 和 SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW ERRORS 和 SHOW WARNINGS 用来显示服务错误或警告消息。]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[了解SQL]]></title>
    <url>%2F2018%2F08%2F01%2F%E4%BA%86%E8%A7%A3SQL%2F</url>
    <content type="text"><![CDATA[1、数据库基础什么是数据库&nbsp;&nbsp;&nbsp;&nbsp;数据库是一个以某种有组织的方式存储的数据集合。理解数据库的一种最简单的办法是将其想象为一个文件柜。此文件柜是一个存放数据的物理位置，不管数据是什么以及如何组织的。 数据库软件应称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操纵的容器。 表&nbsp;&nbsp;&nbsp;&nbsp;在你将资料放入自己id文件柜时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 &nbsp;&nbsp;&nbsp;&nbsp;在数据库领域中，这种文件成为表。表示一种结构化的文件，可用来存储某种特定类型的数据。 表（table）某总特定类型数据的结构化清单&nbsp;&nbsp;&nbsp;&nbsp;存储在表中的数据是一种类型的数据或一个清单。决不应该将顾客的清单与订单的清单存储在同一个数据库表中。&nbsp;&nbsp;&nbsp;&nbsp;数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的。 列和数据类型表由列组成。列中存储着表中某部分信息 列（column）表中的一个字段。所有的表都是由一个或多个列组成的。 &nbsp;&nbsp;&nbsp;&nbsp;数据库中每个列都有相应的数据类型。数据类型定义列可以存储的数据种类。 数据类型（datatype）所容许的数据的类型。每个列表都有相应的数据类型，它限制（或容许）该列中存储的数据 行&nbsp;&nbsp;&nbsp;&nbsp;表中的数据是按行存储的，所保存的每个记录存储在自己的行内。 行（row）表中的一个记录。 主键&nbsp;&nbsp;&nbsp;&nbsp;表中的每一行都应该有可以唯一表示自己的一列。 主键（primary key）一列，其值能够唯一区分表中的每个行。 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许NULL值） 主键的最好的习惯： 不更新主键列中的值； 不重用主键列的值； 不再主键列中使用可能会更改的值。 什么是SQL&nbsp;&nbsp;&nbsp;&nbsp;SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库通信的语言。]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习MarkDown语法 - 基本语法]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%AD%A6%E4%B9%A0MarkDown%E8%AF%AD%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题, 两个#是二级标题,以此类推。支持六级标题。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下: 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要把加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例:1234*我是斜体***这是加粗的文字*****我是斜体加粗***~~我是删除线~~ 效果如下: 我是斜体 这是加粗的文字 我是斜体加粗 我是删除线 三、引用在引用的文字前面加&gt;即可。示例:123&gt;这是引用的内容&gt;&gt;两个引用&gt;&gt;&gt;&gt;&gt;五个引用 效果如下: 这是引用的内容 两个引用 五个引用 四、分割线三个或三个以上的-或者*都可以.示例:1234-------******* 效果如下: 五、图片语法:1![图片alt](图片地址 &quot;图片title&quot;) 示例:1![blockchain](https://niyiwei.github.io/uploads/avatar.jpeg &quot;你以为&quot;) 效果如下: 六、超链接语法:1[超链接名](超链接地址 &quot;超链接title&quot;) 示例:12[你以为](https://niyiwei.github.io &quot;你以为&quot;)[京东](https://jd.com &quot;京东商城&quot;) 效果如下: 你以为 京东 七、列表 无序列表 语法:无序列表用 -+* 任何一种都可以123- 列表一+ 列表二* 列表三 效果如下: 列表一 列表二 列表三 有序列表语法:数字加点123451 .列表内容2 .列表内容3 .列表内容注意: 序号跟内容之间要有空格 效果如下: 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格 一级无序列表内容 二级无序列表内容 二级无序 二级无序 一级无序列表内容 二级无序 二级无序 一级有序列表 二级有序 二级有序 无序无序 一级有序列表 二级无序 二级无序 八、表格语法:1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 效果如下: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间用一个反引号包起来1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123（```） 代码。。。（```）]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
