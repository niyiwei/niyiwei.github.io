---
title: 数据库管理系统.第六章
date: 2018-09-05 20:50:10
tags:
categories:
    - 考试
    - 数据库系统原理
---
# 数据库完整性

## 什么是数据库完整性

数据库完整性是指数据库中数据的 **正确性** 和 **完整性**

<!-- more -->
## 完整性约束条件的对象

列级约束  -> 包括队列的类型、取值范围、精度等的约束
元组约束  -> 指元组中各个字段之间的相互约束
表级约束  -> 指若干元组、关系之间的联系的约束

## 定义与实现完整性约束

+ 实体完整性

    在MySQL中，实体完整性是通过主键约束和候选键约束实现的

    主键列必须遵循的规则
    1. 每一个表只能定义一个主键
    2. 主键的值（键值）必须能够唯一标志表中的每一行记录，不能为空
    3. 复合主键不能包含不必要的多余列
    4. 一个列名在复合主键的列表中只能出现一次


    |约束方式|语句区别|区别|关键字|
    |--|--|--|--|
    |主键约束|CREATE TABLE 或 ALTER TABLE |一个表只能创建一个主键|PRIMARY KEY|
    |候选键约束|CREATE TABKE 或 ALTER TABLE|可以定义若干个候选键|UNIQUE|

+ 参照完整性
```
REFERENCES tbl_name(index_col_name,...)
[ON DELETE reference_option]
[ON UPDATE reference_option]
```
RESTRICT -> 限制策略

CASCADE  -> 级联策略

SET NULL -> 置空策略

NO ACTION -> 不采取实施策略

+ 用户定义的完整性

非空约束 NOT NULL

CHECK 约束
```
CHECK (expr)
```
## 命名完整性约束

```
CONSTRAINT [symbol]
```

symbol -- 指定的约束名字

只能给基于表的完整性约束指定名字，无法给基于列的完整性约束指定名字

## 更新完整性约束

使用 **ALTER TABLE语句** 更新与列表或表有关的各种约束

1. 完整性约束不能直接被修改（先修改，再增加）
2. 使用ALTER TABLE语句，可以独立删除完整性约束，而不会删除表本身。（DROP TABLE语句删除一个表，则表中所有的完整性约束都会被自动删除）

# 触发器

## 什么是触发器

是用户定义在关系表上的一类由事件驱动的数据对象，也是一种保证数据完整性的方法

## 创建触发器

**使用 Create TRIGGER 语句创建触发器**

```
CREATE TRIGGER trigger_name trigger_time trigger_event
ON tbl_name FOR EACH ROW trigger_body
```

## 删除触发器

```
DROP TRIGGER IF EXISTS customers_insert_trigger;
```


## 使用触发器

**INSERT触发器**
在INSERT触发器代码内，可引用一个名为NEW（不区分大小写）的虚拟表，来访问被插入的行

在BEFOR INSERT触发器中，NEW中的值可以被更新

**DELETE触发器**

在DELETE触发器代码内，可引用一个名为**OLD（不区分大小写）**的虚拟表，来访问被删除的行。

**OLD**的值，不能被更新

**UPDATE触发器**

在UPDATE触发器代码内，可引用一个名为**OLD**的虚拟表，来访问UPDATE语句执行前的值，也可以引用一个名为NEW的虚拟表来访问更新后的值。

# 完全性与访问控制

## 用户账号管理

**ROOT用户**

### 使用CREATE USER 语句创建MySQL账户
```
CREATE USER user [IDENTIFIED BY [PASSWORD]'password']
```
+ user 指定创建用户账号 格式：`user_name` @ 'host_name`
+ IDENTIFIED BY 指定用户账号对应的口令
+ PASSWORD 可选项，指定散列口令


### 删除用户

```
DROP USER username[,...]
```

栗子：
```
DROP USER 'user_name'@'user_localhost';
```

### 修改用户账号
```
RENAME USER old_user to new_name [,old_user to new_user]...
```

栗子：
```
RENAME USER 'zhangsan'@'localhost' TO 'wangwu'@'localhost';
```

### 修改用户密码
**使用SET PASSWORD语句修改用户登录口令**
```
SET PASSWORD [FOR USER] = {PASSWORD('new_password') | 'encrypted password'}
```

栗子：
```
SET PASSWORD FOR 'wangwu'@'localhost' = PASSWORD('123456');
```
## 账号权限管理

### 使用GRANT语句为用户授权
```
GRANT 
    priv_type[(column_list)]
        [,priv_type [(column_list)]]...
        ON [object_type] priv_level
        TO user_specification [,user_specification]...
        [WITH GRANT OPTION]
```

栗子：
```
grant select(cust_id,cust_name) on mysql_test.customers to 'zhangsan'@'localhost';
```

授予查询，修改全部字段权限并生成一个账号赋予密码 权限可以转移栗子：
```
GRANT SELECT,UPDATE ON mysql_test.customers to 'zhou'@'localhost' identified by '123' with grant option;
```

授予全部权限栗子：
```
GRANT ALL ON mysql_test.* to 'zhangsan'@'localhost' with grant option;
```

授予用户创建用户的权限
```
GRANT CREATE USER on *.* to 'zhangsan'@'localhost';
```
### 使用REVOKE语句撤销用户权限
```
REVOKE 
    priv_type [(column_list)]
    [, priv_type[(column_list)]]...
    ON [object_type] priv_level
    FROM user [,user]...
```

## 事物与并发控制

### 事物的概念

所谓事物是用户定义的一个 **数据操作序列** ，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务中的操作一般是对数据的更新操作，包括 **增、删、改**。

以 **BEGIN TRANSACTION** 语句开始

以 **COMMIT（提交）** 语句或 **ROLLBACK（回滚）** 语句结束

### 事物的特征

+ 原子性 ：事物是不可分割的最小工作单位
+ 一致性 ：
+ 隔离性
+ 持续性（永久性）

**简称 ACID**

### 并发操作问题

+ 丢失更新：事物T2的提交结果会破坏T1提交的结果
+ 不可重复读：事物T2执行更新操作，使T1无法再现前一次读取结果
+ 读“脏”数据：事物T1修改数据后撤销，使得T2读取的数据与数据库中不一致


### 封锁

一个锁实质上就是允许或阻止一个事务对一个数据对象的存取特权。

1. 排它锁（X锁），用于写操作
2. 共享锁（S锁），用于读操作

我们通常以粒度来描述封锁的数据单元的大小

粒度越细，并发性就越大，但软件复杂性和系统开销就越大。

封锁的级别

封锁的级别又称为一致性级别或隔离度

+ 0级封锁：不重写其他为0级封锁事物的未提交的更新数据（实用价值低）
+ 1级封锁：不允许重写未提交的更新数据。防止了丢失更新的发横
+ 2级封锁：即不重写也不读取为提交的更新数据（防止了读脏数据）
+ 3级封锁：不读未提交的更新数据，不写任何（包括读操作）未提交数据

死锁和活锁

+ 活锁：先来先服务
+ 死活：预防
    + 一次性锁请求
    + 锁请求排序
    + 序列化处理
    + 资源剥夺


**数据库备份与恢复的概念**

**数据备份是** 是指通过 **导出数据** 或者 **复制表文件**的方式来制作数据库的副本；

**数据库恢复** 则是当数据库出现故障或遭到破坏时，将 **备份** 的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。

数据的恢复是以备份为基础的，它是与备份相对应的系统维护和管理操作。

**备份数据的方法**

使用 SELECT INTO ... OUTFILE 语句备份数据

语法：
```
SELECT * INTO OUTFILE 'file_name' export_options | INTO DUMPFILE 'file_name'
[FIELDS
    [TERMINATED BY 'string']
    [[OPTIONALLY] ENCLOSED BY 'char']
    [ESCAPED BY 'char']
]
[LINES TERMINATED BY 'string']
```
栗子：
```
 select * from mysql_test.customers into outfile "/Users/panhaidong/Desktop/backupfile.txt"
    -> FIELDS TERMINATED BY ','
    -> OPTIONALLY ENCLOSED BY ""
    -> LINES TERMINATED BY "?";
```
**恢复数据的方法**

使用 LOAD DATA ... INFILE 语句恢复数据
```
LOAD DATA INFILE 'file_name.txt'
    INTO TABLE tbl_name
    [FIELDS
        [TERMINATED BY 'string']
        [[OPTIONALLY] ENCLOSED BY 'char']
        [ESCAPED BY 'char']
    ]
    [LINES
        [STARTINGBY 'string']
        [TERMINATED BY 'string']
    ]
```