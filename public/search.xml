<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第 2 章 Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F11%2F29%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java 与 C++ 之间有堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 概述对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不需要为每一个new操作去写匹配的 delete/free 代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存。不过一旦出现内存泄漏和内存溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。 运行时数据区域Java 虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机锁管理的内存将会包括以下几个运行时数据区域 程序计数器程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个额计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程互不影响，独立存储，称这类内存区域为“线程私有”的内存。 如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError情况的区域。 Java虚拟机栈Java虚拟机栈(Java Virtual Machine Stacks)是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。 经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack)，这种分发比较粗糙，Java内存区域的划分实际上远比这复杂。 局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型（指向一了一条字节码指令的地址） 其中64位长度的logn和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果现场请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（大部分可以扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。 在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法也会抛出StackOverflowError和OutOfMemoryError异常。 Java 堆对于大多数应用来说,Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。次内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是： 所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配标量替换、配置替换 优化技术将会导致一些微妙的变化发生，所有对象在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所有Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都任然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快地分配内存。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们磁盘一样。在实现时，即可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中内存内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError异常。 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该与Java堆区分开来。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 直接内存直接内存(Direction Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfmemoryerror异常出现。 在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不受Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现Outofmemoryerror异常]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库管理系统-第七章]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[需求描述与分析系统设计系统实现系统测试与维护]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库管理系统.第六章]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[数据库完整性什么是数据库完整性数据库完整性是指数据库中数据的 正确性 和 完整性 完整性约束条件的对象列级约束 -&gt; 包括队列的类型、取值范围、精度等的约束元组约束 -&gt; 指元组中各个字段之间的相互约束表级约束 -&gt; 指若干元组、关系之间的联系的约束 定义与实现完整性约束 实体完整性 在MySQL中，实体完整性是通过主键约束和候选键约束实现的 主键列必须遵循的规则 每一个表只能定义一个主键 主键的值（键值）必须能够唯一标志表中的每一行记录，不能为空 复合主键不能包含不必要的多余列 一个列名在复合主键的列表中只能出现一次 |约束方式|语句区别|区别|关键字| |--|--|--|--| |主键约束|CREATE TABLE 或 ALTER TABLE |一个表只能创建一个主键|PRIMARY KEY| |候选键约束|CREATE TABKE 或 ALTER TABLE|可以定义若干个候选键|UNIQUE| 参照完整性123REFERENCES tbl_name(index_col_name,...)[ON DELETE reference_option][ON UPDATE reference_option] RESTRICT -&gt; 限制策略 CASCADE -&gt; 级联策略 SET NULL -&gt; 置空策略 NO ACTION -&gt; 不采取实施策略 用户定义的完整性 非空约束 NOT NULL CHECK 约束1CHECK (expr) 命名完整性约束1CONSTRAINT [symbol] symbol – 指定的约束名字 只能给基于表的完整性约束指定名字，无法给基于列的完整性约束指定名字 更新完整性约束使用 ALTER TABLE语句 更新与列表或表有关的各种约束 完整性约束不能直接被修改（先修改，再增加） 使用ALTER TABLE语句，可以独立删除完整性约束，而不会删除表本身。（DROP TABLE语句删除一个表，则表中所有的完整性约束都会被自动删除） 触发器什么是触发器是用户定义在关系表上的一类由事件驱动的数据对象，也是一种保证数据完整性的方法 创建触发器使用 Create TRIGGER 语句创建触发器 12CREATE TRIGGER trigger_name trigger_time trigger_eventON tbl_name FOR EACH ROW trigger_body 删除触发器1DROP TRIGGER IF EXISTS customers_insert_trigger; 使用触发器INSERT触发器在INSERT触发器代码内，可引用一个名为NEW（不区分大小写）的虚拟表，来访问被插入的行 在BEFOR INSERT触发器中，NEW中的值可以被更新 DELETE触发器 在DELETE触发器代码内，可引用一个名为OLD（不区分大小写）的虚拟表，来访问被删除的行。 OLD的值，不能被更新 UPDATE触发器 在UPDATE触发器代码内，可引用一个名为OLD的虚拟表，来访问UPDATE语句执行前的值，也可以引用一个名为NEW的虚拟表来访问更新后的值。 完全性与访问控制用户账号管理ROOT用户 使用CREATE USER 语句创建MySQL账户1CREATE USER user [IDENTIFIED BY [PASSWORD]&apos;password&apos;] user 指定创建用户账号 格式：user_name @ ‘host_name` IDENTIFIED BY 指定用户账号对应的口令 PASSWORD 可选项，指定散列口令 删除用户1DROP USER username[,...] 栗子：1DROP USER &apos;user_name&apos;@&apos;user_localhost&apos;; 修改用户账号1RENAME USER old_user to new_name [,old_user to new_user]... 栗子：1RENAME USER &apos;zhangsan&apos;@&apos;localhost&apos; TO &apos;wangwu&apos;@&apos;localhost&apos;; 修改用户密码使用SET PASSWORD语句修改用户登录口令1SET PASSWORD [FOR USER] = &#123;PASSWORD(&apos;new_password&apos;) | &apos;encrypted password&apos;&#125; 栗子：1SET PASSWORD FOR &apos;wangwu&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;); 账号权限管理使用GRANT语句为用户授权123456GRANT priv_type[(column_list)] [,priv_type [(column_list)]]... ON [object_type] priv_level TO user_specification [,user_specification]... [WITH GRANT OPTION] 栗子：1grant select(cust_id,cust_name) on mysql_test.customers to &apos;zhangsan&apos;@&apos;localhost&apos;; 授予查询，修改全部字段权限并生成一个账号赋予密码 权限可以转移栗子：1GRANT SELECT,UPDATE ON mysql_test.customers to &apos;zhou&apos;@&apos;localhost&apos; identified by &apos;123&apos; with grant option; 授予全部权限栗子：1GRANT ALL ON mysql_test.* to &apos;zhangsan&apos;@&apos;localhost&apos; with grant option; 授予用户创建用户的权限1GRANT CREATE USER on *.* to &apos;zhangsan&apos;@&apos;localhost&apos;; 使用REVOKE语句撤销用户权限12345REVOKE priv_type [(column_list)] [, priv_type[(column_list)]]... ON [object_type] priv_level FROM user [,user]... 事物与并发控制事物的概念所谓事物是用户定义的一个 数据操作序列 ，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务中的操作一般是对数据的更新操作，包括 增、删、改。 以 BEGIN TRANSACTION 语句开始 以 COMMIT（提交） 语句或 ROLLBACK（回滚） 语句结束 事物的特征 原子性 ：事物是不可分割的最小工作单位 一致性 ： 隔离性 持续性（永久性） 简称 ACID 并发操作问题 丢失更新：事物T2的提交结果会破坏T1提交的结果 不可重复读：事物T2执行更新操作，使T1无法再现前一次读取结果 读“脏”数据：事物T1修改数据后撤销，使得T2读取的数据与数据库中不一致 封锁一个锁实质上就是允许或阻止一个事务对一个数据对象的存取特权。 排它锁（X锁），用于写操作 共享锁（S锁），用于读操作 我们通常以粒度来描述封锁的数据单元的大小 粒度越细，并发性就越大，但软件复杂性和系统开销就越大。 封锁的级别 封锁的级别又称为一致性级别或隔离度 0级封锁：不重写其他为0级封锁事物的未提交的更新数据（实用价值低） 1级封锁：不允许重写未提交的更新数据。防止了丢失更新的发横 2级封锁：即不重写也不读取为提交的更新数据（防止了读脏数据） 3级封锁：不读未提交的更新数据，不写任何（包括读操作）未提交数据 死锁和活锁 活锁：先来先服务 死活：预防 一次性锁请求 锁请求排序 序列化处理 资源剥夺 数据库备份与恢复的概念 数据备份是 是指通过 导出数据 或者 复制表文件的方式来制作数据库的副本； 数据库恢复 则是当数据库出现故障或遭到破坏时，将 备份 的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。 数据的恢复是以备份为基础的，它是与备份相对应的系统维护和管理操作。 备份数据的方法 使用 SELECT INTO … OUTFILE 语句备份数据 语法：1234567SELECT * INTO OUTFILE &apos;file_name&apos; export_options | INTO DUMPFILE &apos;file_name&apos;[FIELDS [TERMINATED BY &apos;string&apos;] [[OPTIONALLY] ENCLOSED BY &apos;char&apos;] [ESCAPED BY &apos;char&apos;]][LINES TERMINATED BY &apos;string&apos;] 栗子：1234select * from mysql_test.customers into outfile &quot;/Users/panhaidong/Desktop/backupfile.txt&quot; -&gt; FIELDS TERMINATED BY &apos;,&apos; -&gt; OPTIONALLY ENCLOSED BY &quot;&quot; -&gt; LINES TERMINATED BY &quot;?&quot;; 恢复数据的方法 使用 LOAD DATA … INFILE 语句恢复数据1234567891011LOAD DATA INFILE &apos;file_name.txt&apos; INTO TABLE tbl_name [FIELDS [TERMINATED BY &apos;string&apos;] [[OPTIONALLY] ENCLOSED BY &apos;char&apos;] [ESCAPED BY &apos;char&apos;] ] [LINES [STARTINGBY &apos;string&apos;] [TERMINATED BY &apos;string&apos;] ]]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理 - 数据库编程]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第五章 - 数据库编程存储过程存储过程的基本概念存储过程 是一组为了完成某项特定功能的 SQL语句集 其实质就是一段存储在数据库中的代码 它可以由声明示的SQL语句和过程式的SQL语句组成。 可增强SQL语言的功能和灵活性 良好的封装性 高性能 可减少网络流量 可作为一种安全机制来确保数据库的安全性和数据完整性 创建存储过程DELIMITER 命令语法: 修改语句结束标识1DELIMITER $$(用户指定的标识) 使用CREATE PROCEDURE 语句创建存储过程12CREATE PROCEDURE sp_name([proc_parameter[,...]]) routine_body proc_parameter 存储过程参数列表routine_body 存储过程体 [in|out|inout]param_name type 栗子:12345DELIMITER $$CREATE PROCEDURE sp_update_sex(IN cid INT, IN csex CHAR(1))BEGIN UPDATE customers SET cust_sex = csex WHERE cust_id = cid;END$$ 存储过程体使用DELCEAR语句声明局部变量1DECLEAR var_name[...] type [DEFAULT value] 栗子:1DECLEARE cid INT(10); 只能在存储过程体的BEGIN…END语句块中声明 必须在存储过程的开头处声明 作用范围仅限于声明它的BEGIN…EBD语句块 不同于用户变量 局部变量于用户变量的区别： 局部变量声明时，在其前面没有@符号，并且它只能被声明它的BEGIN…END语句块中的语句所使用 用户变量在声明时，会在其名称前面使用@符号，同时已声明的用户变量存在于整个会话之中。 使用SET语句为局部变量赋值1SET var_name = expr[, var_name=expr]... 栗子:1SET cid = 910; 使用SELECT INTO 语句把选定列的值直接存储到局部变量中1SELECT col_name[...] INTO var_name[...] table_expr col_name-指定列名 var_name-指定要赋值的变量名 table_expr-表示SELECT语句中的FROM子句及后面的语法部分 栗子：1SELECT cust_id INTO cid customers WHERE cust_name = &apos;哇哈哈&apos;； 流程控制语句 条件判断语句 IF…THEN …ELSE语句 CASE语句 循环语句 WHILE语句 REPEAT语句 LOOP 语句 LTERATE语句 用于表示退出当前循环 使用DECLARE CURSOR语句创建游标1DECLARE cursor_name CURSOR FOR select_statement 使用 OPEN 语句打开游标1OPEN cursor_name cursor_name -&gt; 指定要打开的游标 使用FETCH…INTO语句读取数据1FETCH cursor_name INTO var_name[var_name]... cursor_name -&gt; 指定已打开的游标 var_name -&gt; 指定存放数据的变量名 使用CLOSE 语句关闭游标1CLOSE cursor_name 调用存储过程使用CALL语句调用存储过程12CALL sp_name([parameter[,...]])call sp_name[()] 栗子:1call sp_update_sex(3,&apos;m&apos;); 删除存储过程使用DROP PROCEDURE 语句删除存储过程 1DROP PROCEDURE [IF EXISTS] sp_name 存储函数什么是存储函数存储函数与存储过程一样，是由SQL语句和过程式语句组成的代码片段 存储函数 存储过程 不能拥有输出参数 可以拥有输出函数 可以直接调用存储函数 需要 CALL 语句调用存储过程 必须包含一条RETURN语句 不允许包含RETURN语句 创建存储函数使用CREATE FUNCTION语句创建存储函数 123CREATE FUNCTION sp_name([func_parameter[,...]]) RETURNS type routine_body RETURNS type 声明存储函数返回值的数据类型；type指定返回值的数据类型 12345678910111213141516DELIMITER $$CREATE FUNCTION fn_search(cid INT) RETURNS CHAR(10) DETERMINISTIC BEGIN DECLARE SEX CHAR(10); SELECT cust_sex INTO SEX FROM customers WHERE cust_id = cid; IF SEX IS NULL THEN RETURN(SELECT &apos;没有该客户&apos;); ELSE IF SEX = &apos;f&apos; THEN RETURN(SELECT &apos;女&apos;); ELSE RETURN(SELECT &apos;男&apos;); END IF ; END IF;END $$ 调用存储函数使用关键字SELECT 调用存储函数1SELECT sp_name([func_parameter[,...]]) 删除存储函数使用DROP FUNCTION语句删除存储函数1DROP FUNCTION [IF EXISTS] sp_name;]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理 - SQL与关系数据库基本操作]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第四章 - SQL与关系数据库基本操作SQL概述什么是SQL结构化查询语言 （Structured Query Language，SQL）是专门用来与数据库通信的语言，它可以帮助用户操作关系数据库 SQL的特点 SQL不是某个特定数据库供应商专用的语言 SQL简单易学 SQL强大、灵活，可以进行非常复杂和高级的数据库操作 SQL的组成 数据查询 数据定义 数据操纵 数据控制 数据定义语言（Date Definition Language，DDL） CREATE 创建数据库或数据库对象 ALTER 对数据库或数据库对象进行修改 DROP 删除数据库或数据库对象 数据库操纵语言（Date Manipulation Language，DML） SELECT 从表或视图中检索数据 INSERT 将数据插入到表或视图中 UPDATE 修改表或视图中的数据 DELETE 从表或视图中删除数据 数据控制语言（Data Control Language，DCL） GRANT 用于授予权限 REVOKE 用于收回权限 嵌入式和动态SQL规则 规定SQL语句在高级程序设计语言中使用的规范方法，以便适应较为复杂的应用 SQL调用和会话规则 SQL调用包括SQL例程和调用规则，以便提高SQL的灵活性、有效性、共享性以及使SQL具有更多的高级语言的特征； SQL会话规则可使应用程序连接到多个SQL的服务器中的某一个，并与之交互。 MySQL预备知识MySQL使用基础关系数据库管理系统（ RDBMS ） LAMP - （Linux Apache MySQL PHP/Perl/Python） WAMP - (Windows Apache MySQL PHP/Perl/Python) MySQL扩展语言要素 常量 字符串常量（也称字面值或标量值） 用单引号或双引号括起来的字符序列，分为ASCLL字符串常量和Unicode字符串常量 数值常量 整数常量 浮点数常量 十六进制常量（每对十六进制数字被转换为一个字符，其最前面有一个字母’X’或“x”） 时间日期常量（用单引号讲表示日期时间的字符串括起来而构成的） 位字段值 格式：b’value’ -&gt; 二进制值 布尔值 TURE -&gt; 1, FALSE -&gt; 0 NULL值 变量 用户变量 用户变量前常添加一个符号@，用于将其与列名区分开 系统变量 大多数系统变量应用于其他SQL语句中时，必须在系统变量前添加两个@ 运算符 算数运算符：+（加），-（减），*（乘），/（除），%（求模） 位运算符：&amp;（位于），|（位或），^（位异或），~（位取反），&gt;&gt;（位右移），&lt;&lt;（位左移） 比较运算符：=，&lt;，&gt;，&gt;=，&lt;=，&lt;&gt;，!=，&lt;=&gt; 逻辑运算符：NOT或！（逻辑非），AND或%%（逻辑与），OR或||（逻辑或），XOR（逻辑异常） 表达式 表达式是常量、变量、列名、复杂计算、运算符和函数的组合 内置函数 数学函数 聚合函数 字符串函数 日期和时间函数 加密函数 控制流程函数 格式化函数 类型转换函数 系统信息函数### 数据定义数据库模式定义####创建数据库使用 CRESTE DATABASE 或 CREATE SCHEMA 语句 语法：123CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name[DEFAULT] CHARACTER SET[=]charset_name|[DEFAULT]COLLATE[=]collation_name 栗子：12mysql&gt; create database if not exists mysql_test default character set = gbk;Query OK, 1 row affected (0.00 sec) []：表示其内容为可选项；|： 用于分割花括号中的选项 选择数据库语法：1USE DATABASE_NAME; 栗子：12mysql&gt; USE mysql_test;Database changed 修改数据库语法：12ALTER &#123;DATABASE|SCHEMA&#125; [db_name]alter_specification... 栗子：1234mysql&gt; ALTER DATABASE mysql_test -&gt; DEFAULT CHARACTER SET gb2312 -&gt; DEFAULT COLLATE gb2312_chinese_ci;Query OK, 1 row affected (0.00 sec) 删除数据库语法:1DROP &#123;DATABASE|SCHEMA&#125; [IF EXISTS] [db_name] 栗子:12mysql&gt; DROP DATABASE IF EXISTS mysql_test;Query OK, 0 rows affected, 1 warning (0.00 sec) 查看数据库语法：12SHOW &#123;DATABASES|SCHEMA&#125;[LIKE &apos;pattern&apos; | WHERE expr] LIKE 关键字用于匹配指定的数据库名称 WHERE 从句用于指定数据库名称查询范围的条件 栗子：123456789101112ysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || mysql_test || performance_schema || study || sys |+--------------------+6 rows in set (0.00 sec) 表定义创建表数据表示关系数据库中最重要的、最基本的数据对象，也是数据存储的基本单位 数据表，被定义为字段的集合，按行和列的格式来存储的，每一行代表一个记录，每一列代表记录中一个字段的取值 CREATE TABLE 语句创建表 主要由： 表创建定义（create definition） 表选项：（table options） 分区选项：（partition options） 语法：123456CREATE [TEMPORARY] TABLE tbl_name( 字段名1 数据类型 [列级完整性约束条件][默认值] [,字段名2 数据类型 [列级完整性约束条件][默认值]] [,表级完整性约束])[ENGINT=引擎类型] 栗子：在一个已有的数据库mysql_test中新建一个包含客户姓名、性别、地址、联系方式等内容的客户基本信息表，要求将客户的id号指定为该表的主键12345678910mysql&gt; CREATE TABLE customers -&gt; ( -&gt; cust_id int not null auto_increment -&gt; ,cust_name varchar(50) not null -&gt; ,cust_sex char(1) not null -&gt; ,cust_address char(50) null -&gt; ,cust_contact char(50) null -&gt; ,primary key (cust_id) -&gt; );Query OK, 0 rows affected (0.05 sec) 更新表使用ALTER TABLE语句，增加或删减列，创建或取消索引，更改原有列的数据类型，重新命名列或表，更改表的评注和表达引擎类型，为表重新创建触发器、存储过程、索引和外建等。 ADD[COLUMN]子句 示例：想数据库mysql_test的表customers中添加一列，并命名为cust_city,要求不能为null，默认值为字符串”Wuhan”,且该列位于原表cust_sex列之后。 语法:12ALTER TABLE mysql_test.customersADD COLUMN cust_city char(10) NOT NULL DEFAULT &apos;Wuhan&apos; AFTER cust_sex; 栗子：123mysql&gt; ALTER TABLE mysql_test.customers ADD COLUMN cust_city char(10) NOT NULL DEFAULT &apos;Wuhan&apos; AFTER cust_sex;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0 CHANGE[COLUMN]子句 (修改表中列的名称或数据类型) 语法：12ALTER TABLE mysql.test.customersCHANGE COLUMN cust_sex sex char(1) NULL DEFULT &apos;M&apos;; 栗子:1234mysql&gt; ALTER TABLE mysql_test.customers -&gt; CHANGE COLUMN cust_sex sex char(2) NULL DEFAULT &apos;M&apos;;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 ALTER[COLUMN]子句 修改或删除表中指定列的默认值 语法：12ALTER TABLE mysql_test.customersALTER COLUMN cust_city SET DEFAULT &apos;Beijing&apos;; 栗子：123mysql&gt; ALTER TABlE mysql_test.customers ALTER COLUMN cust_city SET DEFAULT &apos;Beijing&apos;;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 MODIFY[COLUMN]子句 只修改指定列的数据类型，不会干涉它的列名语法：12ALTER TABLE mysql_test.customersMODIFY COLUMN cust_name char(20) FIRST; 栗子:1234mysql&gt; ALTER TABLE mysql_test.customers -&gt; MODIFY COLUMN cust_name char(11) not null AFTER cust_id;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 DROP[COLUMN]子句 删除列语法： 123mysql&gt; ALTER TABLE mysql_test.customers DROP COLUMN cust_contact;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 RENAME[TO]子句 更新表名 语法:12ALTER TABLE mysql_test.customersRENAME TO my_customers; 栗子：123mysql&gt; ALTER TABLE mysql_test.customers -&gt; RENAME TO backup_customers;Query OK, 0 rows affected (0.00 sec) 删除表语法:1DROP[TEMPORANY] TABLE [IF EXISTS] tb_name [,tb_name] 栗子：12mysql&gt; DROP TABLE IF EXISTS backup_customers;Query OK, 0 rows affected (0.01 sec) 查看表语法：1SHOW [FULL] COLUMN &#123;FROM | IN&#125; tbl_name [&#123;FROM | IN&#125; db_name] [LIKE &apos;pattern&apos; | WHERE expr] 显示指定数据表的结构1&#123;DESCRIBE | DESC&#125; tbl_name [col_name | wild] 栗子： 索引定义索引是DBMS根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表 索引是提高数据文件访问效率的有效方法 索引存在的弊端： 索引是以文件的形式存储的，如果有大量的索引，索引文件可能比数据更快达到最大的文件尺寸 索引在提高查询速度的同时，会降低更新表的速度 普通索引（INDX或KEY） 唯一性索引(UNIQUE) 主键(PRIMARY KEY) 索引通常被创建成单列索引和组合索引 索引的创建：（使用CREATE INDEX语句创建）语法：12CREATE [UNIQUE] INDEX index_name ON tbl_name(index_col_name...) col_name[(length)][ASC|DESC] 栗子：123mysql&gt; CREATE INDEX index_customers -&gt; ON mysql_test.customers(cust_name(3) ASC);Query OK, 0 rows affected (0.02 sec) 组合索引栗子：12mysql&gt; CREATE INDEX index_cust -&gt; ON mysql_test.customers(cust_name, cust_id); 索引的创建：使用 CREATE TABLE 语法创建 语法项 [CONSTRAINT[symbol]] PRIMARY KEY(index_col_name, …),用于表示在创建新表的同时创建该表的主键； 语法项 {INDEX|KEY}index_name,用于表示在创建新表的同时创建该表的索引； 语法项 [CONSTRAINT[symbol]]UNIQUE[INDEX|KEY]index_name 用于表示在创建新表的同时创建该表的唯一性索引 语法项 [CONSTRAINT[symbol]] FOREIGN KEY index_name,用于表示在创建新表的同时创建该表的外建 栗子:123456789101112mysql&gt; create table seller -&gt; ( -&gt; seller_id int not null auto_increment -&gt; ,seller_name char(50) not null -&gt; ,seller_address char(50) null -&gt; ,seller_contact char(50) null -&gt; ,product_type int(5) not null -&gt; ,sales int null -&gt; ,primary key(seller_id, product_type) -&gt; ,index index_seller(sales) -&gt; );Query OK, 0 rows affected (0.02 sec) 索引的创建：使用ALTER TABLE语句创建 语法项：ADD {INDEX | KEY} index_name, 用于表示在修改表的同时为该表添加索引 语法项：ADD [CONSTRAINT [symbol]] PRIMARY KEY (index_col_name,…), 用于表示在创建新表的同时为该表添加主键 语法项：ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]index_name,用于表示在修改表的同时为该表添加唯一性索引 语法项：ADD [CONSTRAINT [symbol]] FOREIGN KEY (index_col_name,…),用于表示在创建新表的同时为该表添加外建 查看索引（SHOW INDEX）语法：1234SHOW &#123;INDEX | INDEXES | KEYS&#125;&#123;FROM | IN&#125; tbl_name[&#123;FROM | IN&#125; db_name][WHERE expr] 栗子：123456789mysql&gt; show index from seller;+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| seller | 0 | PRIMARY | 1 | seller_id | A | 0 | NULL | NULL | | BTREE | | || seller | 0 | PRIMARY | 2 | product_type | A | 0 | NULL | NULL | | BTREE | | || seller | 1 | index_seller | 1 | sales | A | 0 | NULL | NULL | YES | BTREE | | |+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.00 sec) 删除索引：使用DROP INDEX语句语法：1DROP INDEX index_cust ON mysql_test.customers; 栗子：12mysql&gt; drop index index_cust ON customers;Query OK, 0 rows affected (0.02 sec) 使用ALTER TABLE语句删除 选用 DROP PRIMARY KEY 子句用于删除表中的主键，由于一个表中只有一个主键，其也是一个索引 选用DROP INDEX子句用于删除各种类型的索引 选用DROP FOREIGN KEY 子句用于删除外建 栗子:1234ALTER TABLE T_NAMEDROP PRIMARY KEY,DROP INDEX INDEX_NAME,DROP FOREIGN KEY 数据更新插入数据语法:12INSERT [INSERT] tbl_name [(col_name,...)]&#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,...),(...)... 栗子：12mysql&gt; insert into customers(cust_id, cust_name, cust_sex, cust_address, cust_contact) values (901, &apos;张三&apos;, &apos;F&apos;, &apos;北京市&apos;, &apos;朝阳区&apos;);Query OK, 1 row affected (0.02 sec) 使用INSERT … SET 语句插入部分列值数据 使用INSERT …SELECT语句插入子查询数据 删除数据使用DELETE语句删除一行或多行数据 修改数据使用UPDATE语句修改更新一个表中的数据 数据查询SELECT语句语法：123456789SELECT [ALL | DISTINCT | DISTINCTROW]select_expr [, select_expr ...]FROM tbl_name[WHERE where_condition][GROUP BY &#123;col_name|expr|position&#125;[ASC|DESC],...[WITH ROLLUP]][HAVING where_condition][ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC],...][LIMIT &#123;[offset,]row_count | row_count OFFSET offset] 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚合时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的函数 否 列的选择与指定 查询指定列 SELECT col_name1,col_name2 FROM tbl_name 查询所有列 SELECT * FROM tbl_name 定义并使用列的别名 SELECT cust_name as 地址 from customers; 替换查询结果集中的数据 123456CASE WHEN 条件1 THEN 表达式1 WHEN 条件2 THEN 表达式2....ELSE 表达式END [AS] column_alias 例:123456mysql&gt; SELECT cust_name, CASE WHEN cust_sex = &apos;m&apos; THEN &apos;男&apos; ELSE &apos;女&apos; END AS 性别 FROM customers;+-----------+--------+| cust_name | 性别 |+-----------+--------+| 哇哈哈 | 男 |+-----------+--------+ 计算列值123456mysql&gt; SELECT cust_id + 100, cust_name, cust_sex FROM customers;+---------------+-----------+----------+| cust_id + 100 | cust_name | cust_sex |+---------------+-----------+----------+| 101 | 哇哈哈 | m |+---------------+-----------+----------+ 聚合函数：通常是数据库系统中一类系统 内置函数|函数名|说明||:–|:–||COUNT|求组中项数，返回INT类型整数||MAX|求最大值||MIN|求最小值||SUM|返回表达式中所有值的和||AVG|求组中值的平均值||STD或STDDEV|返回给定表达式中所有值的标准值||VARIANC|返回给定表达式中所有值的方差||GROUP_CONTACT|返回由属于一组的列值连接组合而成的结果||BIT_AND|逻辑或||BIR_OR|逻辑与||BIT_XOR|逻辑异或| FROM子句与多表连接查询交叉连接，又称笛卡尔积语法：123SELECT * FROM tbl1 CROSS JOIN tbl2;ORSELECT * FROM tbl1, tbl2; 栗子：12mysql&gt; select * from tbl1 cross join tbl2;mysql&gt; select * from tbl1,tbl2; 内连接语法1SELECT some_columns FROM table1 INNER JOIN table2 ON some_conditions; 栗子:12 等值连接：使用运算符= 非等值连接：使用除=之外的其他比较运算符 自然连接：将一个表与他自身进行连接 外链接 左外链接：在FROM子句中使用关键字LEFT OUTER JOIN 或 LEFT JOIN 右外链接：在FROM子句中使用关键字RIGHT OUTER JOIN 或 RIGHT JOIN 简述左外连接和右外连接的区别 左外链接：也称左连接。以左表为基表，在FROM子中使用关键字“LEFT OUTER JOIN”或关键字 “LEFT JOIN” 来连接两张表。右外连接：也称右连接。以右表为基表，在FROM子句中使用关键字“RIGHT OUTER JOIN”或关键字“RIGHT JOIN”来连接两张表 WHERE子句与条件查询比较运算符 比较运算符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 &lt;=&gt; 不会返回UNKNOWN 判断范围 当查询的过滤条件被限定在值的某个范围时，可以使用关键字“BETWEEN”语法：1SELECT * FROM customers WHERE cust_id BETWEEN 1 AND 2; 使用关键字“IN”可以指定一个值的枚举表，该表中会列举所有可能的值语法：1SELECT * FRON customers WHERE cust_id in (1,2,3,4,5); 判定空值语法：1SELECT * FROM customers WHERE cust_contact is null; IN,ANY,SOME NOT IN , &lt;&gt;ALL 1SELECT * FROM tb_name WHERE col_name &#123;IN|ANY|SOME&#125; (1,2,3) 子查询-结合关键字 “EXIST”使用的子查询 子查询的结果集不为空，则返回TRUE，否则返回FALSE123SELECT * FROM customers WHERE EXISTS (SELECT * FROM customers);SELECT * FROM customers WHERE NOT EXISTS (SELECT * FROM customers); GROUP BY 子句1SELECT * FROM customers GROUP BY &#123;col_name | position&#125;[ASC | DESC],...[WITH ROLLUP] 指定在结果集中不仅包含由GROUP BY 子句分组后的数据行，还包括各分组的汇总行，以及所有分组的整行汇总行，可以得到每个分组以及每个分组汇总级别的值 HAVING 子句1HAVING WHERE_COINDITION HAVING子句 WHERE子句 过滤分组 过滤数据行 可以包含聚合函数 不可以包含聚合函数 在数据分组后进行过滤 在数据分组前过滤 ORDER BY 子句1ORDER BY &#123;col_nae expr | position&#125;[AC | DESC],... ORDER BY GROUP BY 排序产生的输出 分组行，但输出可能不是分组的排序 任意列都可以使用 只可能使用选择列或表达式 不一定需要 若聚合函数一起使用列或表达式，则必须使用 LIMIT子句使用LIMIT子句限制被SELECT语句返回的行数1LIMIT &#123;[offset,] row_count | row_count OFFSET OFFSET&#125; 栗子：123SELECT * FROM customers LIMIT 1,2;SELECT * FROM customers 2 OFFSET 1; 视图什么是视图视图是数据库中的一个对象，它是数据库管理系统提供给用户的以多种角度观察数据库中数据的一种重要机制 视图不是数据库中真实的表，而是一张虚拟表，其自身并不存在 使用视图的优点 集中分散数据 简化查询语句 重用SQL语句 保护数据安全 共享所需数据 更改数据格式创建视图123CREATEVIEW view_name[(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 指定在可更新视图上所进行的修改都需要复符合select_statement中所指定的限制条件 删除视图1drop view [if exists] view_name [,view_name]... 修改视图定义123ALTERVIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 查看视图定义1SHOW CREATE VIEW view_name 更新视图数据1INSERT INTO customers_view VALUES (NULL, &apos;农夫山泉&apos;, &apos;m&apos;, &apos;北京&apos;, &apos;有点甜&apos;); 使用UPDATE语句通过视图修改基本表的数据1UPDATE customers_view SET cust_address = &apos;湖北&apos; WHERE cust_name = &apos;农夫山泉&apos;; 使用DELETE语句通过视图删除基本表的数据1DELETE FROM customers_view WHERE cust_name = &apos;农夫山泉&apos;; 查询数据视图12SELECT * FROM customers_view;`]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库管理系统-第三章-数据库设计]]></title>
    <url>%2F2018%2F08%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[数据库设计数据库设计概述数据库的生命周期 数据库分析与设计阶段 需求分析 概念设计 逻辑设计 物理设计 数据库实现与操作阶段 实现 操作与监督 修改与调整 数据库设计的目标 满足应用功能需求（存、取、删、改） 良好的性能（共享性，完整性，一致性，安全保密性） 数据库设计的内容 数据库结构设计（结构-静态的） 数据库概念结构设计 逻辑结构设计 物理结构设计 数据库行为设计（操作-动态的） 功能设计 事物设计 程序设计 数据库设计的方法 直观设计法（最原始的数据库设计方法） 规范设计法 新奥尔良设计方法：需求分析、概念结构设计、逻辑结构设计、物理结构设计 基于E-R模型的数据库设计方法 基于第三范式的设计方法，是一类结构化设计方法 计算机辅助设计法 数据库设计的过程 需求分析 结构设计 行为设计 数据库实施 加载数据库数据 调试运行应用程序 数据库运行与维护 数据设计的基本步骤需求分析目标：是了解与分析用户的信息及应用处理的需求，并将结果按一定格式整理而形成需求分析报告 该分析报告是后续 概念设计，逻辑设计，物理设计，数据库建立与维护的依据 步骤： 确定数据的范围 支持哪些应用功能 有效地利用计算机设备及数数据库系统的潜在能力 提高数据的应变能力 避免应用过程中对数据库做太多或太大的修改 延长数据库的生命周期 分析数据应用过程-结果是数据库设计结构设计的重要依据 用到哪些数据 数据使用的顺序 对数据作何处理和处理的策略以及结果 收集与分析数据 数据分类表-用于数据的总体描述（静态的结构） 数据元素表-值通常意义下的数据项或属性（静态结构） 任务分类表-一个任务指为完成某个特定处理功能的相对独立的操作序列（动态结构） 数据特征操作表-用以描述任务和数据之间的关系，它包括不同任务对数据执行不同操作的评率（动态） 数据约束 数据的安全保密性 数据的完整性 响应时间 数据恢复 编写需求分析报告 数据的应用功能目标 标明不同用户视图范围 应用处理过程需求说明，包括，数据流程图；任务分类表；数据操作特征表；操作过程说明书。 数据字典，是数据系统中存储三级结构定义的数据库，通常指的是数据库系统中各类数据详细描述的集合。通常包括数据分类表、数据元素表和各类原始资料 数据量 数据约束 概念结构设计 概念模型（自顶向下） 顶层设计 独立于任何软件与硬件 主要目标：最大限度的满足应用需求 逻辑结构设计 层次模型 网状模型 关系模型 面向对象模型 概念设计 –&gt; 模型转换 –&gt; 子模式设计 / 应用程序设计说明 –&gt; 设计评价(检验) –&gt; 物理设计 物理设计具体任务主要是确定数据在存储设备上的 存储结构 及 存取方法 ，因DBMS的不同还可能包括 建立索引 和 聚集，以及 物理块的大小、 缓冲区个数和大小、数据压缩的选择 数据库实施 加载数据：收集、分类、整理校验、输入等 应用程序设计：具有较高的稳定性，并具有试运行的数据基础，也具备了应用程序编制与调试的必要条件。这样编写的应用程序具有较高的稳定性和实用性 数据库试运行 有利于工作人员掌握并熟悉系统 有利于正式运行时避免人为的的操作不当等损害 数据库运行与维护需求分析– 结构设计 / 行为分析 – 数据实施 – 数据库运行与维护 保证数据库的正常运行 系统维护中最困难的工作是 数据库重组与重构 关系数据库设计方法关系数据库设计过程与各级模式应用要求 – 概念模式（E-R图） – 逻辑模式 –内模式 概念结构设计方法E-R图的表示方法1：1 的联系1：N 的联系M：N 的联系单个实体型内的一对多联系 局部信息结构设计： 确定局部范围：局部范围主要依据需求分析报告中标明的用户视图范围来确定。往往与子模式范围相对应 选择实体：数据分类表是选择实体的直接依据，实体选择最大困难时如何区别 实体与属性 选择实体的关键字属性：实体的存在依赖于其 关键字 的存在 确定实体间的联系：数据间的联系必须在概念设计时确定 确定实体的属性：属性分为标识属性和说明属性 全局信息结构设计： 逻辑结构设计方法 将E-R图转化为关系模式 一个实体型转换为一个关系模式，实体的属性作为关系的属性，实体的码作为关系的码 一个一对一联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并 一个一对多联系可以转换为一个独立的关系模式，也可以与N端对应的关系模式合并 一个对多对联系转换为一个关系模式 三个或以上实体间的一个多元联系可以转换为一个关系模式 具有相同码的关系模式可合并 对关系数据模型进行优化 数据逻辑设计的结果，不是唯一的 进一步提高数据库应用系统的性能 根据需要适当地修改、调整数据模型的结构 数据模型的优化 确定各属性间的函数依赖关系 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系 判断每个关系模式的范式，根据实际需要确定最合适的范式 按照需求分析阶段得到的处理要求，分析这些模式对于这样的应用环境是否合适，确定是否要对某些模式进行合并或分解 对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率 设计面向用户的外模式（子模式） 可以通过试图机制在设计使用户视图时，重新定义某些属性的别名，使其更符合用户的习惯，以方便使用 可以对不同级别的用户定义不同的视图，以保证系统的安全性 简化用户对系统的使用 物理设计 建立索引（逻辑连接） 静态建立索引 动态建立索引 建立聚集（物理聚集） 聚集是将相关数据集中存放 的物理存储技术 数据聚集结构的一种有效方式是 块结构方式 数据聚集可在 一个或多个关系上建立]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第二章 · 关系数据库]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第二章 · 关系数据库 关系数据库概述 关系数据模型 关系数据库的规范化理论（范式） 2.1 关系数据库概述关系数据库的产生历史 1970年 IBM的E.F.Codd提出了关系模型，奠定了关系数据库的理论基础 20世纪70年代末 关系方法理论研究和软件系统的研制取得了重大突破 1981年 出现了比较成熟的关系数据库管理技术，证实了关系数据库的优点 高级的非过程语言接口、较好的数据独立性 20世纪80年代后 网状模型和层次模型与低层实现的结合紧密，关系模型具有坚实理论基础，称成为主流数据模型 2.2 关系数据模型组成要素 关系数据结构 关系操作集合 关系完整性约束 关系数据结构 表（Table）是一个二维的数据结构，由表名、列、若干行数据组成 关系（Relation）一个关系逻辑上对应一张二维表，可以为每个关系去一个名称进行表示 基本关系（基本关系表、基表） 查询表 视图表 列（Column）也称字段（Field）或属性（Attribute） 表名必须唯一 字段名必须唯一 不同表中可以出现相同的字段名 属性（Attribute）= 列 行（Row）也成为 元组（Tuple） 或 记录（Record）。表中的数据按行存储 分量（Component）= 具体的数据项 元组（行）中的一个属性值，称为分量 码或键（Key） 属性（或属性组）的值 都能用来 唯一表示该关系的元组，则称这些属性（或属性组）为该关系的码或键 超码或超键（Super Key） 在码中去除某个属性，它仍然是这个关系的码 候选码或候选键（Candidate Key） 在码中不能从中移去任何一个属性，否则它就不再是这个关系的码或键。候选码或候选键是这个关系的最小超码或超键 主属性（Primary Attribute）或非主属性（NonPrimanry Attribute） 包含在任何一个候选码中的属性称为主属性或码属性 主码或主键（Primary Key）主观意愿指定的 在若干个候选码中指定一个唯一标识关系的元组（行） 全码或全键（All Key） 一个关系模式的所有属性集合是这个关系的主码或主键，这样主码或主键称为全码或全键 外码或外键（Foreign Key） 某个属性（或属性组）不是这个关系的主码或候选码，而是另一个关系的主码 域（Domain）表示属性的取值范围 数据类型（Date Type） 每个列都有相应的数据类型，它用于限制（或容许）该列中存储的数据 关系模式（Relation Schema） 关系模型是型（type），关系是值（value），即关系模式是对关系的描述 关系模式是静态的、稳定的 关系是动态的，随时间不断变化的 关系数据库（Relation Database） 所有关系的集合，构成了一个关系数据库 以关系的集合，构成一个关系数据库。 以关系模型作为数据的逻辑模型，并采用关系作为数据的组织方式的一类数据库，其数据操作建立在关系代数的基础上 关系数据库对关系的限定/要求： 每个属性都是不可分解的（不允许表中有表） 每个关系仅仅有一种关系模式 每一个关系模式中的属性必须命名，属性名不同 同一个关系中不允许出现候选码或候选键值完全相同的元组 在关系中元组的顺序（即行序）是无关紧要的，可以任意交换 在关系中属性的顺序（即列序）是无关紧要的，可以任意交换 基本的关系操作 查询（Query） 选择 投影 并 差 笛卡尔积 由上述的操作引出 连接、除、交 插入（Insert） 修改（Delete） 删除（Update） 特点：集合操作方法（一次一集合） 关系数据语言 关系代数语言 SQL 关系演算语言 元组关系演算 域关系演算 运算符任何一种操作都包含三大要素： 操作对象 操作符 集合运算符 关系运算符 比较操作符 逻辑操作符 操作结果 传统的集合运算符 并（UNION） R3 = R1 ∪ R2 两个关系必须有相同的属性个数 差（DIFFERENCE）R3 = R1 - R2 两个关系必须有相同的属性个数 交（INTERSECTION）R3 = R1 ∩ R2 两个关系必须有相同的属性个数 笛卡尔积（CARTESIAN PRODUCT）R3 = R1 × R3 两个关系可以由不相同的属性个数 专门的关系运算选择（SELECT）：Of(R) SELECT 关系名 WHERE 条件由常数、属性名或列名、比较操作符（&gt;、&lt;、=、≥、≤、≠）及逻辑操作符（）组成的条件表达式 投影（PROJECTION）πA（R） PROJECTION 关系名（属性名1，属性名2，…，属性名n） 连接（JOIN） JOIN 关系名1 AND 关系名2 WHERE 条件1、笛卡尔积2、只留属性值相同3、去掉重复列 除（DIVISION）：R ÷ S 1、投影2、笛卡尔积3、全部相同4、得出除表 完整性约束数据库的完整性是值数据库中数据的 正确性、相容性、一致性 分类： 实体完整性约束（Entity Integrity Constraint）主码的组成不能为空，主属性不能是空值NULL 参照完整性约束（Referential Integrity Constraint）定义外码和主码之间的引用规则，要么外码等于主码中某个元组的主码值，要么Null值 用户定义完整性约束（User-defined Integrity Constraint）域完整性约束（针对某一应用环境的完整性约束），其他 执行插入操作的检验 检查实体完整性约束 检查参照完整性约束 检查用户定义完整性约束 执行删除操作 (是否被引用) 一般只需要对被参照关系检查参照完整性约束 执行更新操作上述两种情况的综合 关系数据库的规范化理论 关系模式中可能存在的冗余和异常问题 函数依赖于关键字 范式于关系规范化过程 关系模式中可能存在的冗余和异常问题数据冗余：指同一数据被反复存储的情况 更新异常：数据冗余造成的 插入异常： 删除异常： 函数依赖于关键字什么是函数？ f: a –&gt; B, y=f(x) 分类： 完全函数规范设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的任何真子集X丿，都有 X丿 依赖 Y，则称Y完全函数依赖于X例：X 表 A,B属性 组成 R，并且 X 依赖 Y，且对X中的任何真子集 部分函数依赖设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的存在一个真子集X丿，满足 X丿 依赖 Y，则称Y部分函数依赖于X 传递函数依赖设R为任一给定关系， X,Y,Z为其不同属性子集，若 X 依赖 Y， Y 不依赖 X， Y 依赖 Z， 则有 X 依赖 Z，称为Z传递函数依赖于X 关键字设R为任一给定关系，U为其所含的全部属性集合 X为U的子集，若有完全函数以为 X依赖U，则X为R的一个候选关键字 范式与关系规范化过程一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合，这个过程就叫 规范化（Normalization） 第一范式1NF设R为任意给定关系，若果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式 第二范式设R为任意给定关系，若R为1NF，且其所有非主属性都完全含糊依赖于候选关键字，则R为第二范式 第三范式设R为任意给定关系，若R为2NF，且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式 第三范式的改进形式BCNF设R为任一给定关系，X,Y为其属性集，F为函数依赖集，若R为3NF，且其F中所有函数依赖 X -&gt; Y(Y不属于X)中的X必包含候选关键字，则R为BCNF。]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[检索数据]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[介绍如何使用SELECT语句从表中检索一个或多个数据列。 1、SELECT语句&nbsp;&nbsp;&nbsp;&nbsp;SQL语句由简单的英语单词构成。这些英语单词称为关键字，每个SQL语句都是用一个或多个关键字构成的。 2、检索单个列输入 SELECT prod_name FROM products;分析: 利用SELECT语句从product表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。 SQL语句和大小写 SQL语句不区分大小写，因此SELECT与select是相同的。许多开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。使用空格 在处理SQL语句时，其中所有空格都被忽略。SQL语句可以在一行上给出，也可以分成许多行。多行易于调试。 3、检索多个列&nbsp;&nbsp;&nbsp;&nbsp;要想从一个表中检索多个列，使用相同的SELECT语句。唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须有逗号分隔。 当心逗号 在选择多个列时，一定要在列名之间加上逗号，但最后一个列名不加。 例：SELECT prod_id, prod_name, prod_price FROM products; 4、检索所有列&nbsp;&nbsp;&nbsp;&nbsp;除了指定所需的列外，SELECT语句还可以检索所有的列而不必逐个列出它们。这可以通过在实际列名的位置使用星号（）通配符来达到。例：`SELECT FROM products;` 使用通配符 一般，除非你确实需要表中的每个列，否则最好别使用*通配符。检索不需要的列通常会降低检索和应用程序的性能。 5、检索不同的行&nbsp;&nbsp;&nbsp;&nbsp;SELECT返回所有匹配的行。但是，如果你不想要每个值都出现，怎么办? 使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。例：SELECT DISTINCT vend_id FROM products; 不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price, 除非指定的两个列都不同，否则所有行都将被检索出来。 6、限制结果&nbsp;&nbsp;&nbsp;&nbsp;SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句。 例: SELECT prod_name FROM products LIMIT 5;次语句使用SELECT语句检索单个列。 LIMIT 5指示MySQL返回不多于5行。 为了得出下一个5行，可指定要检索的开始行和行数。 例：SELECT prod_name FROM products LIMIT 5,5; 分析：LIMIT 5,5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数 行0 检索出来的第一行为行0而不是行1。因此， LIMIT 1,1将检索出第二行而不是第一行。在行数不够时 LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行，MySQL将只返回的那么多行。MySQL 5的LIMIT语法 LIMIT 3,4的含义是从行3开始的4行，这容易把人搞糊涂，MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意从行3开始取4行，就像LIMIT 3,4一行。 7、使用完全限定的表名例：SELECT products.prod_name FROM products; 表名也是可以完全限定的 例：SELECT products.prod_name FROM crashcourse.products;]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用MySQL]]></title>
    <url>%2F2018%2F08%2F02%2F%E4%BD%BF%E7%94%A8MySQL%2F</url>
    <content type="text"><![CDATA[1、连接为了连接到MySQL，需要以下信息： 主机名（计算机名）– 如果连接到本地MySQL服务器，为localhost； 端口（如果使用默认端口3306之外的端口） 一个合法的用户名； 用户口令 示例：1mysql -u ben -p -h myserver -P 9999 2、选择数据库在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作之前，需要选择一个数据库。为此，可使用 USE 关键字 关键字（key word）作为MySQL语言组成部分的一个保留字。绝不要用关键字命名一个表或列 示例：1USE crashcourse; 3、了解数据库和表&nbsp;&nbsp;&nbsp;&nbsp;数据库、表、列、用户、权限等的信息被存储在数据库和表中。如果不知道可以使用的数据库名时，可以使用 MySQL的 SHOW 命令来显示这些信息。 示例：1SHOW DATABASES; 为了获取一个数据库内的表的列表，使用 SHOW TABLES;示例：1SHOW TABLES; SHOW 也可以用来显示表列 SHOW COLUMNS FROM customers;DESCRIBE 语句 MySQL支持功DESCRIBE作为SHOW COLUMNS FROM的一种快捷方式。换句话说，DESCRIBE customers; 是SHOW COLUMNS FROM customers;的一种快捷方式。 所支持的其他 SHOW 语句还有： SHOW STATUS; 用于显示广泛的服务器状态信息； SHOW CREATE DATABASE 和 SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW ERRORS 和 SHOW WARNINGS 用来显示服务错误或警告消息。]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[了解SQL]]></title>
    <url>%2F2018%2F08%2F01%2F%E4%BA%86%E8%A7%A3SQL%2F</url>
    <content type="text"><![CDATA[1、数据库基础什么是数据库&nbsp;&nbsp;&nbsp;&nbsp;数据库是一个以某种有组织的方式存储的数据集合。理解数据库的一种最简单的办法是将其想象为一个文件柜。此文件柜是一个存放数据的物理位置，不管数据是什么以及如何组织的。 数据库软件应称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操纵的容器。 表&nbsp;&nbsp;&nbsp;&nbsp;在你将资料放入自己id文件柜时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 &nbsp;&nbsp;&nbsp;&nbsp;在数据库领域中，这种文件成为表。表示一种结构化的文件，可用来存储某种特定类型的数据。 表（table）某总特定类型数据的结构化清单&nbsp;&nbsp;&nbsp;&nbsp;存储在表中的数据是一种类型的数据或一个清单。决不应该将顾客的清单与订单的清单存储在同一个数据库表中。&nbsp;&nbsp;&nbsp;&nbsp;数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的。 列和数据类型表由列组成。列中存储着表中某部分信息 列（column）表中的一个字段。所有的表都是由一个或多个列组成的。 &nbsp;&nbsp;&nbsp;&nbsp;数据库中每个列都有相应的数据类型。数据类型定义列可以存储的数据种类。 数据类型（datatype）所容许的数据的类型。每个列表都有相应的数据类型，它限制（或容许）该列中存储的数据 行&nbsp;&nbsp;&nbsp;&nbsp;表中的数据是按行存储的，所保存的每个记录存储在自己的行内。 行（row）表中的一个记录。 主键&nbsp;&nbsp;&nbsp;&nbsp;表中的每一行都应该有可以唯一表示自己的一列。 主键（primary key）一列，其值能够唯一区分表中的每个行。 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许NULL值） 主键的最好的习惯： 不更新主键列中的值； 不重用主键列的值； 不再主键列中使用可能会更改的值。 什么是SQL&nbsp;&nbsp;&nbsp;&nbsp;SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库通信的语言。]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习MarkDown语法 - 基本语法]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%AD%A6%E4%B9%A0MarkDown%E8%AF%AD%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题, 两个#是二级标题,以此类推。支持六级标题。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下: 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要把加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例:1234*我是斜体***这是加粗的文字*****我是斜体加粗***~~我是删除线~~ 效果如下: 我是斜体 这是加粗的文字 我是斜体加粗 我是删除线 三、引用在引用的文字前面加&gt;即可。示例:123&gt;这是引用的内容&gt;&gt;两个引用&gt;&gt;&gt;&gt;&gt;五个引用 效果如下: 这是引用的内容 两个引用 五个引用 四、分割线三个或三个以上的-或者*都可以.示例:1234-------******* 效果如下: 五、图片语法:1![图片alt](图片地址 &quot;图片title&quot;) 示例:1![blockchain](https://niyiwei.github.io/uploads/avatar.jpeg &quot;你以为&quot;) 效果如下: 六、超链接语法:1[超链接名](超链接地址 &quot;超链接title&quot;) 示例:12[你以为](https://niyiwei.github.io &quot;你以为&quot;)[京东](https://jd.com &quot;京东商城&quot;) 效果如下: 你以为 京东 七、列表 无序列表 语法:无序列表用 -+* 任何一种都可以123- 列表一+ 列表二* 列表三 效果如下: 列表一 列表二 列表三 有序列表语法:数字加点123451 .列表内容2 .列表内容3 .列表内容注意: 序号跟内容之间要有空格 效果如下: 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格 一级无序列表内容 二级无序列表内容 二级无序 二级无序 一级无序列表内容 二级无序 二级无序 一级有序列表 二级有序 二级有序 无序无序 一级有序列表 二级无序 二级无序 八、表格语法:1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 效果如下: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间用一个反引号包起来1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123（```） 代码。。。（```）]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
