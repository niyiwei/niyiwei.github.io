<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[虚拟机性能监控与故障处理工具]]></title>
    <url>%2F2018%2F12%2F05%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Sun JDK监控和故障处理工具 JDK的命令行工具 名称 主要作用 jps JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程 jstat JVM Statistics Monitoring Tool，用户手机HotSpot虚拟机各方面的运行数据 jinfo Configuration Info for Java，显示虚拟机配置信息 jmap Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件） jhat JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果 jstack Stack Trace for Java，显示虚拟机的线程快照 jps:虚拟机进程状况工具jps（JVM Process Status Tool）功能和ps类似；可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class， main（）函数所在的类）名词以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier， LVMID）。 jsp 命令格式 jps [options] [hostid] 123456MacBook-Pro:/ xx$ jps10339 Launcher5928 UnixLauncher719611197 JpsMacBook-Pro:/ xx$ jsp 工具主要选项 选项 作用 -q 只输出LVMID，省略主类的名词 -m 输出虚拟机进程启动时传递给主类main()函数的参数 -l 输出主类的全名，如果进程执行的是Jar包，输入Jar路径 -v 输出虚拟机进程启动时JVM参数 jstat: 虚拟机统计信息监视工具jstat(JVM Statistics-Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地货远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。 jstat命令格式为： jstat [option vmid [interval[s|ms] [count]]] 对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是： 1[protocaol:][//]lvmid[@hostname[:port]/servername] 参数 interval 和 count 代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要没250毫秒查询一次进程 2764垃圾收集状况，一共查询20次，那命令应当是: 1jstat -gc 2764 250 20 选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行器编译状况 如下表： 选项 作用 -class 监视类装载、卸载数量、总空间以及类装载所耗费的时间 -gc 监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久带等的容量、已用空间、GC时间合计等信息 -gccapacity 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 -gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 -gccause 与gcutil功能一样，但是会额输出导致上一次GC产生的原因 -gcnew 监视新生代GC状况 -gcnewcapacity 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间 -gcold 监视老年代GC状况 -gcoldcapacity 监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间 -gcpermcapacity 输出永久代使用到的最大、最小空间 -compiler 输出JIT编译器编译过的方法、耗时等信息 -printcompilation 输出已被JIT编译的方法 例： 123MacBook-Pro:/ xx$ jstat -gcutil 10339 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 67.99 0.00 74.13 0.17 96.26 91.85 2 0.012 0 0.000 0.012 新生代Eden区（E，表示Eden）使用了74.13%的空间，两个Survivor(S0,S1,表示Survivor0， Survivor1)，老年代（0，表示Old）。程序运行以来共发生Minor GC（YGC， 表示 Young GC）2次，总耗时 0.012秒，发生Full GC（FGC，表示 Full GC）0次，Full GC总耗时(FGCT, 表示Full GC Time)为0秒，所有GC总耗时(GCT,表示GC Time)为0.012秒。 jinfo： Java配置信息工具jinfo(Configuration Info for Java)的作用是实时地查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的 -flag选项进行查询了 使用 java -XX:+PrintFlagsFinal查看参数默认值也是一个很好的选择。jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。jinfo还提供运行期修改参数的能力，可以使用 -flag [+|-] name 或者 -flag name=value 修改一部分运行期可写的虚拟机参数值。 命令格式： jinfo [option] pid jmap: Java内存映像工具jmap(Memory Map for Java)命令用于生成堆转储快照（一般称为heapdump或dump文件）。 jmap的作用不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。 jmap命令格式： jmp [option] vmid 主要选项 选项 作用 -dump 生成Java堆转储快照。格式为：-dump:[live, ]format=b, file=,其中live子参数说明是否只dump出存活的对象 -finalizerinfo 显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效 -heap 显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Sloaris平台下有效 -histo 显示堆中对象统计信息，包括类、实例数量、合计容量 -permstat 以ClassLoader为统计口径显示永久代内存状态。只在Linux/Sloaris平台下有效 -F 当虚拟机进程对 -dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Sloaris平台下有效 jhat：虚拟机堆转储快照分析工具Sun JDK提供 jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后可以在浏览器中查看。 一般不会使用，原因： 一般不会在部署应用程序的服务器上直接分析dump文件，如果分析也会尽量复制到其他机器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程。jhat的分析功能相对来说有点简陋 jstack： Java堆栈跟踪工具jstack（Stack Trace for Java） 命令用于生成虚拟机当期时刻的线程快照（一般称为threaddump或者 Javacore文件）。 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如县线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程停顿的常见原因。 jstack [option] vmid option选项的合法值与具体含义: 选项 作用 -F 当正常输出的请求不被响应时，强制输出线程堆栈 -l 除堆栈外，显示关于锁的附加信息 -m 如果调用本地方法的话，可以显示C/C++的堆栈 HSDIS： JIT生成代码反汇编JDK 的可视化工具JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole和VisualVM，这两个工具是JDK的正式成员，没有被贴上“丶supported and experimental”的标签 JConsole是在JDK1.5时期就已经提供的虚拟机监控工具，VisualVM在JDK1.6中才首次发布，现在已经成为Sun（Oracle）主力推动的多合一故障处理工具，并且已经从JDK中分离出来成为可以独立发展的开源项目。 VisualVM: 多合一故障处理工具VisualVM兼容范围与插件安装VisualVM基于NetBeans平台开发，因此它一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM可以做到： 显示虚拟机进程以及进程的配置、环境信息（jps， jinfo） 监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack） dump以及分析对转存储快照（jmap、jhat） 方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法 离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行bug反馈 其他插件…]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分配与回收策略]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[对象的内存分配主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下可能直接分配在老年代中，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 虚拟机提供了 -XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。 12345678910111213private static final int _1MB = 1024 * 1024; public static void main(String[] args) &#123; testAllocation(); &#125; private static void testAllocation() &#123; byte[] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; allocation4 = new byte[4 * _1MB]; &#125; GC: 123456789Heap PSYoungGen total 9216K, used 8192K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) eden space 8192K, 100% used [0x00000007bf600000,0x00000007bfe00000,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000) to space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000) ParOldGen total 10240K, used 4096K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) object space 10240K, 40% used [0x00000007bec00000,0x00000007bf000010,0x00000007bf600000) Metaspace used 3301K, capacity 4496K, committed 4864K, reserved 1056768K class space used 368K, capacity 388K, committed 512K, reserved 1048576K 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息（更坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序应该避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。 虚拟机提供了一个 -XX:PretenureSizeThreshold参数，令这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存） 长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能够识别哪些对象应放在新生代，哪些对象应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一个程度（默认为15岁），就将会被晋升到老年代中。对象老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold设置 动态对象年龄判定为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无序等到MaxTenuringThreshold中要求的年龄。 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 “冒险”：新生代使用复制收集算法，但为了内存利用率,只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代所有对象都存活）,就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现 Serial收集器Serial收集器是最基本、发展历史最悠久的收集器，是一个单线程收集器，但它的”单线程“的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。”Stop The World“这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接受的。 优点： 简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完成一样，在实现上，这两种收集器也共用了想当多的代码。 ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMD收集器配合工作。 Parallel Scavenge 收集器Parallel Scavenge收集器是一个新生代收集器，使用复制算法的收集器，又是并行的多线程收集器 Parallel Scavenge收集器的特点是他的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户现场停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%； 停顿时间越短就越适合与用户交互的程序，良好的相应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMills参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。 MaxGCPauseMillis参数允许的值大于0的毫秒数，收集器尽可能地保证内存回收话费的时间不超过设定值。不过不要认为如果把这个参数设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的 系统把新生代调小一些，收集300MB的新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些。 Serial Old收集器Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途就是作为在JDK1.5以及之前的版本与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理“算法。这个收集器是JDK1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择。由于老年代Serial Old收集器在服务端应用性能上的”拖累“，使用Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS的组合”给力“ CMS收集器（Concurrent Mark Sweep）CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分Java应用集中在互联网站或者B/S系统的服务端上。这类应用尤其总是服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。 CMS收集器是基于”标记-清楚“算法是限定，分为4个步骤 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中，初始标记、重新标记这两个步骤依然需要”Stop The World“。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始化标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集低、低停顿，也称之为并发低停顿收集器（Concurrent Low Pause Collection） 缺点： CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是(CPU数量+3)/4，也就是当CPU在4个以上时，并发回收垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%。为了应付这种情况，虚拟机提供了一种称为”增量式并发收集器“（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占来模拟多任务机制的思想一样，就是在并发标记、清理的时候让GC现场、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些。 CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现”Concurrent Mode Failure“失败而导致另一次Full Gc的产生。由于CMS并发清除阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在档次收集中处理掉它们，只好留待下一次GC时再清理掉。 CMS是基于”标记-清除“算法实现的收集器，意味着收集结束时会有大量空间碎片产生。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactATFullCollection开挂参数（默认开启），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理） G1收集器G1(Garbage-First)收集器是当今收集器技术发展的最前沿成果之一。 G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行到GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果 空间整合：与CMS的”标记-清理“算法不同，G1从整体来看是基于”标记-整理“算法实现的收集器，从局部（两个Region之间）上来看是基于”复制“算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。 可预测的停顿：这是G1相对CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 G1收集器的运行大致可划分为以下几个步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 理解GC日志阅读GC日志是处理Java虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。 JVM的GC日志的主要参数包括如下几个： -XX:+PrintGC 输出GC日志 -XX:+PrintGCDetails 输出GC的详细日志 -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -Xloggc:../logs/gc.log 日志文件的输出路径 每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设置者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志： 1234567891011121314Java HotSpot(TM) 64-Bit Server VM (25.91-b14) for windows-amd64 JRE (1.8.0_91-b14), built on Apr 1 2016 00:58:32 by "java_re" with MS VC++ 10.0 (VS2010)Memory: 4k page, physical 4080628k(616944k free), swap 8159380k(3974088k free)CommandLine flags: -XX:InitialHeapSize=15728640 -XX:MaxHeapSize=15728640 -XX:MaxNewSize=10485760 -XX:NewSize=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 0.106: [GC (Allocation Failure) --[PSYoungGen: 5591K-&gt;5591K(9216K)] 9687K-&gt;9751K(15360K), 0.0015296 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 0.108: [Full GC (Ergonomics) [PSYoungGen: 5591K-&gt;0K(9216K)] [ParOldGen: 4160K-&gt;5133K(6144K)] 9751K-&gt;5133K(15360K), [Metaspace: 2632K-&gt;2632K(1056768K)], 0.0045365 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] Heap PSYoungGen total 9216K, used 4178K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 51% used [0x00000000ff600000,0x00000000ffa14930,0x00000000ffe00000) from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) to space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen total 6144K, used 5133K [0x00000000ff000000, 0x00000000ff600000, 0x00000000ff600000) object space 6144K, 83% used [0x00000000ff000000,0x00000000ff5035b8,0x00000000ff600000) Metaspace used 2639K, capacity 4486K, committed 4864K, reserved 1056768K class space used 285K, capacity 386K, committed 512K, reserved 1048576K 如果前面有数字 则代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。 GC日志开头的 “[GC” 和 “[Full GC” 说明这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的，如果有“Full”，说明这次GC是发生了Stop-The-World的 0.106: [GC (Allocation Failure) –[PSYoungGen: 5591K-&gt;5591K(9216K)] 9687K-&gt;9751K(15360K), 0.0015296 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 0.108: [Full GC (Ergonomics) [PSYoungGen: 5591K-&gt;0K(9216K)] [ParOldGen: 4160K-&gt;5133K(6144K)] 9751K-&gt;5133K(15360K), [Metaspace: 2632K-&gt;2632K(1056768K)], 0.0045365 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] 1、”0.106”和”0.108”这两个数字代表了GC发生的时间，这个数字是从Java虚拟机启动以来经过的秒数。 2、GC日志开头的“[GC”和“[FULL GC”说明了这次垃圾收集的停顿类型，而不是用来区分老年代GC还是新生代GC的。如果有FULL，说明这次GC是发生了Stop-The-World的。新生代收集器ParNew也会出现”[Full GC”（这一般是因为分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示”FULL GC(System)”。 3、接下来的”[DefNew”、”[Tenured”、”[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器都是密切相关的。 例如：使用ParNew收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变为”[ParNew”，意为”Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为”PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。 4、后面方括号内部的“5591K-&gt;0K(9216K)”，含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）” 5、而在方括号之外的“9751K-&gt;5133K(15360K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）” 6、再往后“0.0015296 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的数据 [Times: user=0.00 sys=0.00, real=0.00 secs]。这里的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。墙钟时间包括各种各种非运算的等待耗时，例如等待磁盘I/O等，而CPU时间不包括这些耗时。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集算法]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标记-清除算法（Mark-Sweep）最基础的收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 主要不足有两个： 效率问题，标记和清除两个过程的效率都不高 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法（Copying）它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点：算法的代价是将内存缩小为了原来的一半， 现在的商业虚拟机都是采用这种手机算法来回收新生代，IBM公司的专门研究表明，新生代的对象98%是“朝生夕死”的，所以不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚刚用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这是指老年代）进行分配担保（Handle Promotion）。 内存的分配担保就好比我们去银行借款，如果信誉良好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集存活对象时，这些对象还将通过分配担保机制 进入老年代。 标记-整理算法（Mark-Compact）复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对使用的内存所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”算法，标记过程与“标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以为的内存。 分代收集算法（Generation Collection）这种算法并没有什么新的思想，这是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用”标记-清理“或者”标记-整理“算法来进行回收。 HotSpot 的算法实现枚举根节点从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里的引用，那么必然会消耗很多时间。 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项工作必须在一个能确保一致性的快照中进行—这里”一致性“的意思是指整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为”Stop The World“）的其中一个重要原因，即使是在号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。 安全点在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个实现的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。 实际上，HotSpot也的确没有为每条指令都生成OopMap，只是在”特定的位置“记录了这些信息，这些位置称为”安全点（Safepoint）“，即程序执行时并非在所有地方都停顿下来开始GC，只有在达到安全点时才停顿。Safepoint的既不能太少已致于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负荷。所以安全点的选定基本上是以程序”是否具有让程序长时间执行的特征“为标准进行选定的–因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，”长时间执行“的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。 对于Safepoint，另一个需要考虑的问题时如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都”跑“到最近的安全点上再停顿下来。这里有两种方法可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它”跑“到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。 主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序”不执行“的时候，就是没有分配CPU时间，比如 线程处于Sleep状态或者Blocked状态，这是线程无法响应JVM的中断请求，“走”到安全带地方去中断挂起，JVM也显然不太可能等待线程重新分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。 安全区域是值在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意开始GC都是安全的。 在线程执行到Safe Region在红的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在程序要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直接受到可以安全离开Safe Region信号为止。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[概述说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。实际上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。在胚胎期时，人们就在思考GC需要完成的3件事情： 哪些内存需要回收 什么时候回收 如何回收 为什么我们需要了解GC和内存分呢？ 答案：当需要排插各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些技术实施必要的监控和调节。 Java内存运行时区域的各个部分中，其中 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不许地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和内存回收都具备确定性，在这几个区域就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。 而Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。 对象已死吗在堆里面放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。 引用计数算法(Reference Counting)给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的 缺点： 很难解决对象之间相互循环引用的问题 例如： 12objA.instance = objBobjB.instance = objA 除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问了，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。 测试代码如下： 12345678910111213141516171819202122public class ReferenceCountingGC &#123; private static final int _1MB = 1024 * 1024; public Object instance = null; /** * 唯一的意思就是占点内存，以便能在GC日志中看清楚是否被回收过. */ private byte[] bigSize = new byte[2 * _1MB]; public static void main(String[] args) &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; System.gc(); &#125;&#125; 结果如下： 1234567891011[GC (System.gc()) [PSYoungGen: 5973K-&gt;528K(9216K)] 5973K-&gt;536K(19456K), 0.0013165 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 528K-&gt;0K(9216K)] [ParOldGen: 8K-&gt;427K(10240K)] 536K-&gt;427K(19456K), [Metaspace: 3304K-&gt;3304K(1056768K)], 0.0126967 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] Heap PSYoungGen total 9216K, used 82K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) eden space 8192K, 1% used [0x00000007bf600000,0x00000007bf614920,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000) to space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000) ParOldGen total 10240K, used 427K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) object space 10240K, 4% used [0x00000007bec00000,0x00000007bec6ac58,0x00000007bf600000) Metaspace used 3311K, capacity 4496K, committed 4864K, reserved 1056768K class space used 369K, capacity 388K, committed 512K, reserved 1048576K 可达性分析算法（Reachability Analysis）在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析来断定对象是否存活的。 这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连接时，则证明此对象是不可用的。 在Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 再谈引用JDK1.2之后，Java堆引用的概念进行了扩充，将引用分为强引用（Strong Reference），软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的应用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后提供了 SoftReference类来实现软引用 弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱应用。 虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。 生存还是死亡即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是次对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行” 如果这个对象被判定有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法时对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果被某变量或这对象的成员变量引用，则第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了 回收方法区永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。 假如一个字符串“abc”已经进入常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说 就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判断一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用类”的条件则相对苛刻许多。类需要满足下面三个条件才算是“无用类” 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 虚拟机可以对满足以上3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了 -Xnoclassgs参数进行控制，还可以使用-verbose:class以及-XX:+TraceLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中 -verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:traceClassUnLoading参数需要FastDebug版的虚拟机支持。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OutOfMemoryError异常]]></title>
    <url>%2F2018%2F12%2F04%2FOutOfMemoryError%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfmemoryError(OOM)异常的可能 Java堆溢出Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在对象数量达到最大堆的容量限制后就会产生内存溢出异常。 参数: -Xms20m (将堆的最小值) -Xmx20m (堆的最大值) -XX:+HeapDumpOnOutOfMemoryError (让虚拟机在内存溢出异常时Dump出当前内存堆转储快照以便事后进行分析) 当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError” 会跟着进一步提示 “Java heap space”。 要解决这个区域的异常，一般的手段实现通过内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Lock）还是内存溢出（Memory Overflow）。 虚拟机栈和本地方法栈溢出由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数(设置本地方法栈大小)存在，但实际是无效的，栈容量只由-Xss参数设定。 在Java虚拟机规范中描述了两种异常 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 方法区和运行时常量池溢出参数： -XX:PermSize 方法区大小 -XX:MaxPermSize 方法区最大值 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。 方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 本机直接内存溢出DirectMemory 容量可通过 -XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值(-Xmx指定)一样。 由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO,那就可以考虑检查一下是不是这方面的原因。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第 2 章 Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F11%2F29%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java 与 C++ 之间有堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 概述对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不需要为每一个new操作去写匹配的 delete/free 代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存。不过一旦出现内存泄漏和内存溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。 运行时数据区域Java 虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机锁管理的内存将会包括以下几个运行时数据区域 程序计数器程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个额计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程互不影响，独立存储，称这类内存区域为“线程私有”的内存。 如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError情况的区域。 Java虚拟机栈Java虚拟机栈(Java Virtual Machine Stacks)是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。 经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack)，这种分发比较粗糙，Java内存区域的划分实际上远比这复杂。 局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型（指向一了一条字节码指令的地址） 其中64位长度的logn和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果现场请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（大部分可以扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。 在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法也会抛出StackOverflowError和OutOfMemoryError异常。 Java 堆对于大多数应用来说,Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。次内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是： 所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配标量替换、配置替换 优化技术将会导致一些微妙的变化发生，所有对象在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所有Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都任然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快地分配内存。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们磁盘一样。在实现时，即可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中内存内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError异常。 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该与Java堆区分开来。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 直接内存直接内存(Direction Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfmemoryerror异常出现。 在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不受Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现Outofmemoryerror异常 HotSpot 虚拟机对象探秘对象的创建虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完后便可完全确定,为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边,空闲的内存放在另一边，中间放着一个指针作为分解点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump the Pointer)。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List) 除如何划分可用空间之外，还有另一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时了原来的指针来分配内存当前情况。解决这个问题有两种方案。 一种是：对分配内存空间的动作进行同步处理–实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性； 一种是：把内存分配的动作按照线程划分为不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer， TLABA）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机使用使用TLAB，可以通过 -XX:+/-UseTLAB 参数来设定。 内存分配完后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段都是数据类型所对应的零值。 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。 在上面工作都做完后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始 —&gt;方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码是否跟随invokespecial指令所决定），执行new指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对其填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分可用于存储对象自身的运行时数据，如 哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32bit和64bit，官方称为“Mark Word”。 对象头的另外一部分是类型指针，即对象指向它的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象大大小，但是从数组的元数据中却无法确定数组的大小。 HotSpot虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配在一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍数或者2倍)，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 对象的访问定位建立对象是为使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决与虚拟机实现而定的。 目前主流的访问方式有 “使用句柄” 和 “直接指针两种” 使用句柄Java堆中将会划分出一块内存来作为句柄持，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 直接指针Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址 优势 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常客观的执行成本。 虚拟机Sun HotSpot使用的是 直接指针 进行对象访问]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 · 关系数据库]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第二章 · 关系数据库 关系数据库概述 关系数据模型 关系数据库的规范化理论（范式） 2.1 关系数据库概述关系数据库的产生历史 1970年 IBM的E.F.Codd提出了关系模型，奠定了关系数据库的理论基础 20世纪70年代末 关系方法理论研究和软件系统的研制取得了重大突破 1981年 出现了比较成熟的关系数据库管理技术，证实了关系数据库的优点 高级的非过程语言接口、较好的数据独立性 20世纪80年代后 网状模型和层次模型与低层实现的结合紧密，关系模型具有坚实理论基础，称成为主流数据模型 2.2 关系数据模型组成要素 关系数据结构 关系操作集合 关系完整性约束 关系数据结构 表（Table）是一个二维的数据结构，由表名、列、若干行数据组成 关系（Relation）一个关系逻辑上对应一张二维表，可以为每个关系去一个名称进行表示 基本关系（基本关系表、基表） 查询表 视图表 列（Column）也称字段（Field）或属性（Attribute） 表名必须唯一 字段名必须唯一 不同表中可以出现相同的字段名 属性（Attribute）= 列 行（Row）也成为 元组（Tuple） 或 记录（Record）。表中的数据按行存储 分量（Component）= 具体的数据项 元组（行）中的一个属性值，称为分量 码或键（Key） 属性（或属性组）的值 都能用来 唯一表示该关系的元组，则称这些属性（或属性组）为该关系的码或键 超码或超键（Super Key） 在码中去除某个属性，它仍然是这个关系的码 候选码或候选键（Candidate Key） 在码中不能从中移去任何一个属性，否则它就不再是这个关系的码或键。候选码或候选键是这个关系的最小超码或超键 主属性（Primary Attribute）或非主属性（NonPrimanry Attribute） 包含在任何一个候选码中的属性称为主属性或码属性 主码或主键（Primary Key）主观意愿指定的 在若干个候选码中指定一个唯一标识关系的元组（行） 全码或全键（All Key） 一个关系模式的所有属性集合是这个关系的主码或主键，这样主码或主键称为全码或全键 外码或外键（Foreign Key） 某个属性（或属性组）不是这个关系的主码或候选码，而是另一个关系的主码 域（Domain）表示属性的取值范围 数据类型（Date Type） 每个列都有相应的数据类型，它用于限制（或容许）该列中存储的数据 关系模式（Relation Schema） 关系模型是型（type），关系是值（value），即关系模式是对关系的描述 关系模式是静态的、稳定的 关系是动态的，随时间不断变化的 关系数据库（Relation Database） 所有关系的集合，构成了一个关系数据库 以关系的集合，构成一个关系数据库。 以关系模型作为数据的逻辑模型，并采用关系作为数据的组织方式的一类数据库，其数据操作建立在关系代数的基础上 关系数据库对关系的限定/要求： 每个属性都是不可分解的（不允许表中有表） 每个关系仅仅有一种关系模式 每一个关系模式中的属性必须命名，属性名不同 同一个关系中不允许出现候选码或候选键值完全相同的元组 在关系中元组的顺序（即行序）是无关紧要的，可以任意交换 在关系中属性的顺序（即列序）是无关紧要的，可以任意交换 基本的关系操作 查询（Query） 选择 投影 并 差 笛卡尔积 由上述的操作引出 连接、除、交 插入（Insert） 修改（Delete） 删除（Update） 特点：集合操作方法（一次一集合） 关系数据语言 关系代数语言 SQL 关系演算语言 元组关系演算 域关系演算 运算符任何一种操作都包含三大要素： 操作对象 操作符 集合运算符 关系运算符 比较操作符 逻辑操作符 操作结果 传统的集合运算符 并（UNION） R3 = R1 ∪ R2 两个关系必须有相同的属性个数 差（DIFFERENCE）R3 = R1 - R2 两个关系必须有相同的属性个数 交（INTERSECTION）R3 = R1 ∩ R2 两个关系必须有相同的属性个数 笛卡尔积（CARTESIAN PRODUCT）R3 = R1 × R3 两个关系可以由不相同的属性个数 专门的关系运算选择（SELECT）：Of(R) SELECT 关系名 WHERE 条件由常数、属性名或列名、比较操作符（&gt;、&lt;、=、≥、≤、≠）及逻辑操作符（）组成的条件表达式 投影（PROJECTION）πA（R） PROJECTION 关系名（属性名1，属性名2，…，属性名n） 连接（JOIN） JOIN 关系名1 AND 关系名2 WHERE 条件1、笛卡尔积2、只留属性值相同3、去掉重复列 除（DIVISION）：R ÷ S 1、投影2、笛卡尔积3、全部相同4、得出除表 完整性约束数据库的完整性是值数据库中数据的 正确性、相容性、一致性 分类： 实体完整性约束（Entity Integrity Constraint）主码的组成不能为空，主属性不能是空值NULL 参照完整性约束（Referential Integrity Constraint）定义外码和主码之间的引用规则，要么外码等于主码中某个元组的主码值，要么Null值 用户定义完整性约束（User-defined Integrity Constraint）域完整性约束（针对某一应用环境的完整性约束），其他 执行插入操作的检验 检查实体完整性约束 检查参照完整性约束 检查用户定义完整性约束 执行删除操作 (是否被引用) 一般只需要对被参照关系检查参照完整性约束 执行更新操作上述两种情况的综合 关系数据库的规范化理论 关系模式中可能存在的冗余和异常问题 函数依赖于关键字 范式于关系规范化过程 关系模式中可能存在的冗余和异常问题数据冗余：指同一数据被反复存储的情况 更新异常：数据冗余造成的 插入异常： 删除异常： 函数依赖于关键字什么是函数？ f: a –&gt; B, y=f(x) 分类： 完全函数规范设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的任何真子集X丿，都有 X丿 依赖 Y，则称Y完全函数依赖于X例：X 表 A,B属性 组成 R，并且 X 依赖 Y，且对X中的任何真子集 部分函数依赖设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的存在一个真子集X丿，满足 X丿 依赖 Y，则称Y部分函数依赖于X 传递函数依赖设R为任一给定关系， X,Y,Z为其不同属性子集，若 X 依赖 Y， Y 不依赖 X， Y 依赖 Z， 则有 X 依赖 Z，称为Z传递函数依赖于X 关键字设R为任一给定关系，U为其所含的全部属性集合 X为U的子集，若有完全函数以为 X依赖U，则X为R的一个候选关键字 范式与关系规范化过程一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合，这个过程就叫 规范化（Normalization） 第一范式1NF设R为任意给定关系，若果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式 第二范式设R为任意给定关系，若R为1NF，且其所有非主属性都完全含糊依赖于候选关键字，则R为第二范式 第三范式设R为任意给定关系，若R为2NF，且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式 第三范式的改进形式BCNF设R为任一给定关系，X,Y为其属性集，F为函数依赖集，若R为3NF，且其F中所有函数依赖 X -&gt; Y(Y不属于X)中的X必包含候选关键字，则R为BCNF。]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[检索数据]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[介绍如何使用SELECT语句从表中检索一个或多个数据列。 1、SELECT语句&nbsp;&nbsp;&nbsp;&nbsp;SQL语句由简单的英语单词构成。这些英语单词称为关键字，每个SQL语句都是用一个或多个关键字构成的。 2、检索单个列输入 SELECT prod_name FROM products;分析: 利用SELECT语句从product表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。 SQL语句和大小写 SQL语句不区分大小写，因此SELECT与select是相同的。许多开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。使用空格 在处理SQL语句时，其中所有空格都被忽略。SQL语句可以在一行上给出，也可以分成许多行。多行易于调试。 3、检索多个列&nbsp;&nbsp;&nbsp;&nbsp;要想从一个表中检索多个列，使用相同的SELECT语句。唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须有逗号分隔。 当心逗号 在选择多个列时，一定要在列名之间加上逗号，但最后一个列名不加。 例：SELECT prod_id, prod_name, prod_price FROM products; 4、检索所有列&nbsp;&nbsp;&nbsp;&nbsp;除了指定所需的列外，SELECT语句还可以检索所有的列而不必逐个列出它们。这可以通过在实际列名的位置使用星号（）通配符来达到。例：`SELECT FROM products;` 使用通配符 一般，除非你确实需要表中的每个列，否则最好别使用*通配符。检索不需要的列通常会降低检索和应用程序的性能。 5、检索不同的行&nbsp;&nbsp;&nbsp;&nbsp;SELECT返回所有匹配的行。但是，如果你不想要每个值都出现，怎么办? 使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。例：SELECT DISTINCT vend_id FROM products; 不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price, 除非指定的两个列都不同，否则所有行都将被检索出来。 6、限制结果&nbsp;&nbsp;&nbsp;&nbsp;SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句。 例: SELECT prod_name FROM products LIMIT 5;次语句使用SELECT语句检索单个列。 LIMIT 5指示MySQL返回不多于5行。 为了得出下一个5行，可指定要检索的开始行和行数。 例：SELECT prod_name FROM products LIMIT 5,5; 分析：LIMIT 5,5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数 行0 检索出来的第一行为行0而不是行1。因此， LIMIT 1,1将检索出第二行而不是第一行。在行数不够时 LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行，MySQL将只返回的那么多行。MySQL 5的LIMIT语法 LIMIT 3,4的含义是从行3开始的4行，这容易把人搞糊涂，MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意从行3开始取4行，就像LIMIT 3,4一行。 7、使用完全限定的表名例：SELECT products.prod_name FROM products; 表名也是可以完全限定的 例：SELECT products.prod_name FROM crashcourse.products;]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用MySQL]]></title>
    <url>%2F2018%2F08%2F02%2F%E4%BD%BF%E7%94%A8MySQL%2F</url>
    <content type="text"><![CDATA[1、连接为了连接到MySQL，需要以下信息： 主机名（计算机名）– 如果连接到本地MySQL服务器，为localhost； 端口（如果使用默认端口3306之外的端口） 一个合法的用户名； 用户口令 示例：1mysql -u ben -p -h myserver -P 9999 2、选择数据库在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作之前，需要选择一个数据库。为此，可使用 USE 关键字 关键字（key word）作为MySQL语言组成部分的一个保留字。绝不要用关键字命名一个表或列 示例：1USE crashcourse; 3、了解数据库和表&nbsp;&nbsp;&nbsp;&nbsp;数据库、表、列、用户、权限等的信息被存储在数据库和表中。如果不知道可以使用的数据库名时，可以使用 MySQL的 SHOW 命令来显示这些信息。 示例：1SHOW DATABASES; 为了获取一个数据库内的表的列表，使用 SHOW TABLES;示例：1SHOW TABLES; SHOW 也可以用来显示表列 SHOW COLUMNS FROM customers;DESCRIBE 语句 MySQL支持功DESCRIBE作为SHOW COLUMNS FROM的一种快捷方式。换句话说，DESCRIBE customers; 是SHOW COLUMNS FROM customers;的一种快捷方式。 所支持的其他 SHOW 语句还有： SHOW STATUS; 用于显示广泛的服务器状态信息； SHOW CREATE DATABASE 和 SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW ERRORS 和 SHOW WARNINGS 用来显示服务错误或警告消息。]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[了解SQL]]></title>
    <url>%2F2018%2F08%2F01%2F%E4%BA%86%E8%A7%A3SQL%2F</url>
    <content type="text"><![CDATA[1、数据库基础什么是数据库&nbsp;&nbsp;&nbsp;&nbsp;数据库是一个以某种有组织的方式存储的数据集合。理解数据库的一种最简单的办法是将其想象为一个文件柜。此文件柜是一个存放数据的物理位置，不管数据是什么以及如何组织的。 数据库软件应称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操纵的容器。 表&nbsp;&nbsp;&nbsp;&nbsp;在你将资料放入自己id文件柜时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 &nbsp;&nbsp;&nbsp;&nbsp;在数据库领域中，这种文件成为表。表示一种结构化的文件，可用来存储某种特定类型的数据。 表（table）某总特定类型数据的结构化清单&nbsp;&nbsp;&nbsp;&nbsp;存储在表中的数据是一种类型的数据或一个清单。决不应该将顾客的清单与订单的清单存储在同一个数据库表中。&nbsp;&nbsp;&nbsp;&nbsp;数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的。 列和数据类型表由列组成。列中存储着表中某部分信息 列（column）表中的一个字段。所有的表都是由一个或多个列组成的。 &nbsp;&nbsp;&nbsp;&nbsp;数据库中每个列都有相应的数据类型。数据类型定义列可以存储的数据种类。 数据类型（datatype）所容许的数据的类型。每个列表都有相应的数据类型，它限制（或容许）该列中存储的数据 行&nbsp;&nbsp;&nbsp;&nbsp;表中的数据是按行存储的，所保存的每个记录存储在自己的行内。 行（row）表中的一个记录。 主键&nbsp;&nbsp;&nbsp;&nbsp;表中的每一行都应该有可以唯一表示自己的一列。 主键（primary key）一列，其值能够唯一区分表中的每个行。 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许NULL值） 主键的最好的习惯： 不更新主键列中的值； 不重用主键列的值； 不再主键列中使用可能会更改的值。 什么是SQL&nbsp;&nbsp;&nbsp;&nbsp;SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库通信的语言。]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习MarkDown语法 - 基本语法]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%AD%A6%E4%B9%A0MarkDown%E8%AF%AD%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题, 两个#是二级标题,以此类推。支持六级标题。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下: 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要把加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例:1234*我是斜体***这是加粗的文字*****我是斜体加粗***~~我是删除线~~ 效果如下: 我是斜体 这是加粗的文字 我是斜体加粗 我是删除线 三、引用在引用的文字前面加&gt;即可。示例:123&gt;这是引用的内容&gt;&gt;两个引用&gt;&gt;&gt;&gt;&gt;五个引用 效果如下: 这是引用的内容 两个引用 五个引用 四、分割线三个或三个以上的-或者*都可以.示例:1234-------******* 效果如下: 五、图片语法:1![图片alt](图片地址 &quot;图片title&quot;) 示例:1![blockchain](https://niyiwei.github.io/uploads/avatar.jpeg &quot;你以为&quot;) 效果如下: 六、超链接语法:1[超链接名](超链接地址 &quot;超链接title&quot;) 示例:12[你以为](https://niyiwei.github.io &quot;你以为&quot;)[京东](https://jd.com &quot;京东商城&quot;) 效果如下: 你以为 京东 七、列表 无序列表 语法:无序列表用 -+* 任何一种都可以123- 列表一+ 列表二* 列表三 效果如下: 列表一 列表二 列表三 有序列表语法:数字加点123451 .列表内容2 .列表内容3 .列表内容注意: 序号跟内容之间要有空格 效果如下: 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格 一级无序列表内容 二级无序列表内容 二级无序 二级无序 一级无序列表内容 二级无序 二级无序 一级有序列表 二级有序 二级有序 无序无序 一级有序列表 二级无序 二级无序 八、表格语法:1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 效果如下: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间用一个反引号包起来1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123（```） 代码。。。（```）]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
