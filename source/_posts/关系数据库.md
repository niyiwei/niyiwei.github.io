---
layout: 第二章
title: 第二章 · 关系数据库
date: 2018-08-23 21:50:13
tags:
categories:
    - 考试
    - 数据库系统原理
---
# 第二章 · 关系数据库
+ 关系数据库概述
+ 关系数据模型
+ 关系数据库的规范化理论（范式）

<!-- more -->

## 2.1 关系数据库概述

### 关系数据库的产生历史

+ 1970年 IBM的E.F.Codd提出了关系模型，奠定了关系数据库的理论基础
+ 20世纪70年代末 关系方法理论研究和软件系统的研制取得了重大突破
+ 1981年 出现了比较成熟的关系数据库管理技术，证实了关系数据库的优点
> 高级的非过程语言接口、较好的数据独立性
+ 20世纪80年代后 网状模型和层次模型与低层实现的结合紧密，关系模型具有坚实理论基础，称成为主流数据模型


## 2.2 关系数据模型

### 组成要素

+ 关系数据结构
+ 关系操作集合
+ 关系完整性约束


### 关系数据结构
+ 表（Table）是一个二维的数据结构，由表名、列、若干行数据组成
+ 关系（Relation）一个关系逻辑上对应一张二维表，可以为每个关系去一个名称进行表示
    + 基本关系（基本关系表、基表）
    + 查询表
    + 视图表
+ 列（Column）也称字段（Field）或属性（Attribute）
    + 表名必须唯一
    + 字段名必须唯一
    + 不同表中可以出现相同的字段名
+ 属性（Attribute）= **列**
+ 行（Row）也成为 **元组（Tuple）** 或 **记录（Record）**。表中的数据按行存储
+ 分量（Component）= **具体的数据项** 
 
    元组（行）中的一个属性值，称为分量
+ 码或键（Key）
    
    **属性（或属性组）的值** 都能用来 **唯一**表示该关系的元组，则称这些属性（或属性组）为该关系的码或键
+ 超码或超键（Super Key）

	在码中去除某个属性，它仍然是这个关系的码
+ 候选码或候选键（Candidate Key）

	在码中不能从中移去任何一个属性，否则它就不再是这个关系的码或键。候选码或候选键是这个关系的最小超码或超键
	
+ 主属性（Primary Attribute）或非主属性（NonPrimanry Attribute）

	包含在任何一个候选码中的属性称为主属性或码属性
	
+ 主码或主键（Primary Key）主观意愿指定的

	在若干个候选码中指定一个唯一标识关系的元组（行）
+ 全码或全键（All Key）

	一个关系模式的所有属性集合是这个关系的主码或主键，这样主码或主键称为全码或全键
+ 外码或外键（Foreign Key）

	某个属性（或属性组）不是这个关系的主码或候选码，而是另一个关系的主码
+ 域（Domain）表示属性的取值范围
+ 数据类型（Date Type）

	每个列都有相应的数据类型，它用于限制（或容许）该列中存储的数据
+ 关系模式（Relation Schema）

	关系模型是型（type），关系是值（value），即关系模式是对关系的描述
	关系模式是静态的、稳定的
	关系是动态的，随时间不断变化的
+ 关系数据库（Relation Database）

	所有关系的集合，构成了一个关系数据库
	以关系的集合，构成一个关系数据库。
	以关系模型作为数据的逻辑模型，并采用关系作为数据的组织方式的一类数据库，其数据操作建立在关系代数的基础上
	关系数据库对关系的限定/要求：
	1. 每个属性都是不可分解的（不允许表中有表）
	2. 每个关系仅仅有一种关系模式
	3. 每一个关系模式中的属性必须命名，属性名不同
	4. 同一个关系中不允许出现候选码或候选键值完全相同的元组
	5. 在关系中元组的顺序（即行序）是无关紧要的，可以任意交换
	6. 在关系中属性的顺序（即列序）是无关紧要的，可以任意交换
   
### 基本的关系操作
+ 查询（Query）
	+ 选择
	+ 投影
	+ 并
	+ 差
	+ 笛卡尔积
  > 由上述的操作引出 连接、除、交
+ 插入（Insert）
+ 修改（Delete）
+ 删除（Update）

特点：集合操作方法（一次一集合）

### 关系数据语言
1. 关系代数语言
2. SQL
3. 关系演算语言
	1. 元组关系演算
	2. 域关系演算

### 运算符
任何一种操作都包含三大要素：

+ 操作对象
+ 操作符
	1. 集合运算符
	2. 关系运算符
	3. 比较操作符
	4. 逻辑操作符
+ 操作结果

### 传统的集合运算符

- 并（UNION）	R3 = R1 ∪ R2 两个关系必须有相同的属性个数
- 差（DIFFERENCE）R3 = R1 - R2 两个关系必须有相同的属性个数
- 交（INTERSECTION）R3 = R1 ∩ R2 两个关系必须有相同的属性个数
- 笛卡尔积（CARTESIAN PRODUCT）R3 = R1 × R3 两个关系可以由不相同的属性个数

### 专门的关系运算

选择（SELECT）：Of(R)
> SELECT 关系名 WHERE 条件
> 由常数、属性名或列名、比较操作符（>、<、=、≥、≤、≠）及逻辑操作符（）组成的条件表达式

投影（PROJECTION）πA（R）
> PROJECTION 关系名（属性名1，属性名2，...，属性名n）

连接（JOIN）
> JOIN 关系名1 AND 关系名2 WHERE 条件
1、笛卡尔积
2、只留属性值相同
3、去掉重复列

除（DIVISION）：R ÷ S

1、投影
2、笛卡尔积
3、全部相同
4、得出除表

### 完整性约束

数据库的完整性是值数据库中数据的 **正确性**、**相容性**、**一致性**

分类：
+ 实体完整性约束（Entity Integrity Constraint）主码的组成不能为空，主属性不能是空值NULL
+ 参照完整性约束（Referential Integrity Constraint）定义外码和主码之间的引用规则，要么外码等于主码中某个元组的主码值，要么Null值
+ 用户定义完整性约束（User-defined Integrity Constraint）域完整性约束（针对某一应用环境的完整性约束），其他

执行插入操作的检验
1. 检查实体完整性约束
2. 检查参照完整性约束
3. 检查用户定义完整性约束

执行删除操作  (是否被引用)
1. 一般只需要对被参照关系检查参照完整性约束

执行更新操作
上述两种情况的综合

## 关系数据库的规范化理论
1. 关系模式中可能存在的冗余和异常问题
2. 函数依赖于关键字
3. 范式于关系规范化过程

### 关系模式中可能存在的冗余和异常问题

**数据冗余**：指同一数据被反复存储的情况

**更新异常**：数据冗余造成的

**插入异常**：

**删除异常**：

### 函数依赖于关键字

什么是函数？ f: a --> B, y=f(x)

分类：

#### 完全函数规范
设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的任何真子集X丿，都有 X丿 依赖 Y，则称Y完全函数依赖于X
例：X 表  A,B属性 组成 R，并且 X 依赖 Y，且对X中的任何真子集

#### 部分函数依赖
设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的存在一个真子集X丿，满足 X丿 依赖 Y，则称Y部分函数依赖于X

#### 传递函数依赖
设R为任一给定关系， X,Y,Z为其不同属性子集，若 X 依赖 Y， Y 不依赖 X， Y 依赖 Z， 则有 X 依赖 Z，称为Z传递函数依赖于X

#### 关键字
设R为任一给定关系，U为其所含的全部属性集合 X为U的子集，若有完全函数以为 X依赖U，则X为R的一个候选关键字

### 范式与关系规范化过程

一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合，这个过程就叫 **规范化（Normalization）**

#### 第一范式1NF
设R为任意给定关系，若果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式

#### 第二范式
设R为任意给定关系，若R为1NF，且其所有非主属性都完全含糊依赖于候选关键字，则R为第二范式

#### 第三范式
设R为任意给定关系，若R为2NF，且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式

#### 第三范式的改进形式BCNF
设R为任一给定关系，X,Y为其属性集，F为函数依赖集，若R为3NF，且其F中所有函数依赖 X -> Y(Y不属于X)中的X必包含候选关键字，则R为BCNF。