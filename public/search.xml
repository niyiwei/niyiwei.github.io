<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内存分配与回收策略]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[对象的内存分配主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下可能直接分配在老年代中，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 虚拟机提供了 -XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。 12345678910111213private static final int _1MB = 1024 * 1024; public static void main(String[] args) &#123; testAllocation(); &#125; private static void testAllocation() &#123; byte[] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; allocation4 = new byte[4 * _1MB]; &#125; GC: 123456789Heap PSYoungGen total 9216K, used 8192K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) eden space 8192K, 100% used [0x00000007bf600000,0x00000007bfe00000,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000) to space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000) ParOldGen total 10240K, used 4096K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) object space 10240K, 40% used [0x00000007bec00000,0x00000007bf000010,0x00000007bf600000) Metaspace used 3301K, capacity 4496K, committed 4864K, reserved 1056768K class space used 368K, capacity 388K, committed 512K, reserved 1048576K 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息（更坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序应该避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。 虚拟机提供了一个 -XX:PretenureSizeThreshold参数，令这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存） 长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能够识别哪些对象应放在新生代，哪些对象应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设置为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一个程度（默认为15岁），就将会被晋升到老年代中。对象老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold设置 动态对象年龄判定为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无序等到MaxTenuringThreshold中要求的年龄。 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 “冒险”：新生代使用复制收集算法，但为了内存利用率,只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代所有对象都存活）,就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现 Serial收集器Serial收集器是最基本、发展历史最悠久的收集器，是一个单线程收集器，但它的”单线程“的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。”Stop The World“这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接受的。 优点： 简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完成一样，在实现上，这两种收集器也共用了想当多的代码。 ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMD收集器配合工作。 Parallel Scavenge 收集器Parallel Scavenge收集器是一个新生代收集器，使用复制算法的收集器，又是并行的多线程收集器 Parallel Scavenge收集器的特点是他的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户现场停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%； 停顿时间越短就越适合与用户交互的程序，良好的相应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMills参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。 MaxGCPauseMillis参数允许的值大于0的毫秒数，收集器尽可能地保证内存回收话费的时间不超过设定值。不过不要认为如果把这个参数设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的 系统把新生代调小一些，收集300MB的新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些。 Serial Old收集器Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途就是作为在JDK1.5以及之前的版本与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理“算法。这个收集器是JDK1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择。由于老年代Serial Old收集器在服务端应用性能上的”拖累“，使用Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS的组合”给力“ CMS收集器（Concurrent Mark Sweep）CMS收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分Java应用集中在互联网站或者B/S系统的服务端上。这类应用尤其总是服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。 CMS收集器是基于”标记-清楚“算法是限定，分为4个步骤 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中，初始标记、重新标记这两个步骤依然需要”Stop The World“。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始化标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集低、低停顿，也称之为并发低停顿收集器（Concurrent Low Pause Collection） 缺点： CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是(CPU数量+3)/4，也就是当CPU在4个以上时，并发回收垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%。为了应付这种情况，虚拟机提供了一种称为”增量式并发收集器“（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占来模拟多任务机制的思想一样，就是在并发标记、清理的时候让GC现场、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些。 CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现”Concurrent Mode Failure“失败而导致另一次Full Gc的产生。由于CMS并发清除阶段用户线程还在运行着，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在档次收集中处理掉它们，只好留待下一次GC时再清理掉。 CMS是基于”标记-清除“算法实现的收集器，意味着收集结束时会有大量空间碎片产生。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactATFullCollection开挂参数（默认开启），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理） G1收集器G1(Garbage-First)收集器是当今收集器技术发展的最前沿成果之一。 G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行到GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果 空间整合：与CMS的”标记-清理“算法不同，G1从整体来看是基于”标记-整理“算法实现的收集器，从局部（两个Region之间）上来看是基于”复制“算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。 可预测的停顿：这是G1相对CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 G1收集器的运行大致可划分为以下几个步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 理解GC日志阅读GC日志是处理Java虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。 JVM的GC日志的主要参数包括如下几个： -XX:+PrintGC 输出GC日志 -XX:+PrintGCDetails 输出GC的详细日志 -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -Xloggc:../logs/gc.log 日志文件的输出路径 每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设置者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志： 1234567891011121314Java HotSpot(TM) 64-Bit Server VM (25.91-b14) for windows-amd64 JRE (1.8.0_91-b14), built on Apr 1 2016 00:58:32 by "java_re" with MS VC++ 10.0 (VS2010)Memory: 4k page, physical 4080628k(616944k free), swap 8159380k(3974088k free)CommandLine flags: -XX:InitialHeapSize=15728640 -XX:MaxHeapSize=15728640 -XX:MaxNewSize=10485760 -XX:NewSize=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 0.106: [GC (Allocation Failure) --[PSYoungGen: 5591K-&gt;5591K(9216K)] 9687K-&gt;9751K(15360K), 0.0015296 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 0.108: [Full GC (Ergonomics) [PSYoungGen: 5591K-&gt;0K(9216K)] [ParOldGen: 4160K-&gt;5133K(6144K)] 9751K-&gt;5133K(15360K), [Metaspace: 2632K-&gt;2632K(1056768K)], 0.0045365 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] Heap PSYoungGen total 9216K, used 4178K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 51% used [0x00000000ff600000,0x00000000ffa14930,0x00000000ffe00000) from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) to space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen total 6144K, used 5133K [0x00000000ff000000, 0x00000000ff600000, 0x00000000ff600000) object space 6144K, 83% used [0x00000000ff000000,0x00000000ff5035b8,0x00000000ff600000) Metaspace used 2639K, capacity 4486K, committed 4864K, reserved 1056768K class space used 285K, capacity 386K, committed 512K, reserved 1048576K 如果前面有数字 则代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。 GC日志开头的 “[GC” 和 “[Full GC” 说明这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的，如果有“Full”，说明这次GC是发生了Stop-The-World的 0.106: [GC (Allocation Failure) –[PSYoungGen: 5591K-&gt;5591K(9216K)] 9687K-&gt;9751K(15360K), 0.0015296 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 0.108: [Full GC (Ergonomics) [PSYoungGen: 5591K-&gt;0K(9216K)] [ParOldGen: 4160K-&gt;5133K(6144K)] 9751K-&gt;5133K(15360K), [Metaspace: 2632K-&gt;2632K(1056768K)], 0.0045365 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] 1、”0.106”和”0.108”这两个数字代表了GC发生的时间，这个数字是从Java虚拟机启动以来经过的秒数。 2、GC日志开头的“[GC”和“[FULL GC”说明了这次垃圾收集的停顿类型，而不是用来区分老年代GC还是新生代GC的。如果有FULL，说明这次GC是发生了Stop-The-World的。新生代收集器ParNew也会出现”[Full GC”（这一般是因为分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示”FULL GC(System)”。 3、接下来的”[DefNew”、”[Tenured”、”[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器都是密切相关的。 例如：使用ParNew收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变为”[ParNew”，意为”Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为”PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。 4、后面方括号内部的“5591K-&gt;0K(9216K)”，含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）” 5、而在方括号之外的“9751K-&gt;5133K(15360K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）” 6、再往后“0.0015296 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的数据 [Times: user=0.00 sys=0.00, real=0.00 secs]。这里的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。墙钟时间包括各种各种非运算的等待耗时，例如等待磁盘I/O等，而CPU时间不包括这些耗时。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集算法]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标记-清除算法（Mark-Sweep）最基础的收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 主要不足有两个： 效率问题，标记和清除两个过程的效率都不高 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法（Copying）它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点：算法的代价是将内存缩小为了原来的一半， 现在的商业虚拟机都是采用这种手机算法来回收新生代，IBM公司的专门研究表明，新生代的对象98%是“朝生夕死”的，所以不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚刚用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这是指老年代）进行分配担保（Handle Promotion）。 内存的分配担保就好比我们去银行借款，如果信誉良好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集存活对象时，这些对象还将通过分配担保机制 进入老年代。 标记-整理算法（Mark-Compact）复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对使用的内存所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。 根据老年代的特点，有人提出了另外一种“标记-整理”算法，标记过程与“标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以为的内存。 分代收集算法（Generation Collection）这种算法并没有什么新的思想，这是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用”标记-清理“或者”标记-整理“算法来进行回收。 HotSpot 的算法实现枚举根节点从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里的引用，那么必然会消耗很多时间。 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项工作必须在一个能确保一致性的快照中进行—这里”一致性“的意思是指整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为”Stop The World“）的其中一个重要原因，即使是在号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。 安全点在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个实现的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。 实际上，HotSpot也的确没有为每条指令都生成OopMap，只是在”特定的位置“记录了这些信息，这些位置称为”安全点（Safepoint）“，即程序执行时并非在所有地方都停顿下来开始GC，只有在达到安全点时才停顿。Safepoint的既不能太少已致于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负荷。所以安全点的选定基本上是以程序”是否具有让程序长时间执行的特征“为标准进行选定的–因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，”长时间执行“的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。 对于Safepoint，另一个需要考虑的问题时如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都”跑“到最近的安全点上再停顿下来。这里有两种方法可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它”跑“到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。 主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序”不执行“的时候，就是没有分配CPU时间，比如 线程处于Sleep状态或者Blocked状态，这是线程无法响应JVM的中断请求，“走”到安全带地方去中断挂起，JVM也显然不太可能等待线程重新分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。 安全区域是值在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意开始GC都是安全的。 在线程执行到Safe Region在红的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在程序要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直接受到可以安全离开Safe Region信号为止。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[概述说起垃圾收集（Garbage Collection，GC），大部分人都把这项技术当做Java语言的伴生产物。实际上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。在胚胎期时，人们就在思考GC需要完成的3件事情： 哪些内存需要回收 什么时候回收 如何回收 为什么我们需要了解GC和内存分呢？ 答案：当需要排插各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些技术实施必要的监控和调节。 Java内存运行时区域的各个部分中，其中 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不许地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和内存回收都具备确定性，在这几个区域就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。 而Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。 对象已死吗在堆里面放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。 引用计数算法(Reference Counting)给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的 缺点： 很难解决对象之间相互循环引用的问题 例如： 12objA.instance = objBobjB.instance = objA 除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问了，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。 测试代码如下： 12345678910111213141516171819202122public class ReferenceCountingGC &#123; private static final int _1MB = 1024 * 1024; public Object instance = null; /** * 唯一的意思就是占点内存，以便能在GC日志中看清楚是否被回收过. */ private byte[] bigSize = new byte[2 * _1MB]; public static void main(String[] args) &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; System.gc(); &#125;&#125; 结果如下： 1234567891011[GC (System.gc()) [PSYoungGen: 5973K-&gt;528K(9216K)] 5973K-&gt;536K(19456K), 0.0013165 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 528K-&gt;0K(9216K)] [ParOldGen: 8K-&gt;427K(10240K)] 536K-&gt;427K(19456K), [Metaspace: 3304K-&gt;3304K(1056768K)], 0.0126967 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] Heap PSYoungGen total 9216K, used 82K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) eden space 8192K, 1% used [0x00000007bf600000,0x00000007bf614920,0x00000007bfe00000) from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000) to space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000) ParOldGen total 10240K, used 427K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) object space 10240K, 4% used [0x00000007bec00000,0x00000007bec6ac58,0x00000007bf600000) Metaspace used 3311K, capacity 4496K, committed 4864K, reserved 1056768K class space used 369K, capacity 388K, committed 512K, reserved 1048576K 可达性分析算法（Reachability Analysis）在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析来断定对象是否存活的。 这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连接时，则证明此对象是不可用的。 在Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 再谈引用JDK1.2之后，Java堆引用的概念进行了扩充，将引用分为强引用（Strong Reference），软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的应用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后提供了 SoftReference类来实现软引用 弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱应用。 虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。 生存还是死亡即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是次对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行” 如果这个对象被判定有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法时对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果被某变量或这对象的成员变量引用，则第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了 回收方法区永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。 假如一个字符串“abc”已经进入常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说 就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判断一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用类”的条件则相对苛刻许多。类需要满足下面三个条件才算是“无用类” 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 虚拟机可以对满足以上3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了 -Xnoclassgs参数进行控制，还可以使用-verbose:class以及-XX:+TraceLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中 -verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:traceClassUnLoading参数需要FastDebug版的虚拟机支持。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OutOfMemoryError异常]]></title>
    <url>%2F2018%2F12%2F04%2FOutOfMemoryError%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfmemoryError(OOM)异常的可能 Java堆溢出Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在对象数量达到最大堆的容量限制后就会产生内存溢出异常。 参数: -Xms20m (将堆的最小值) -Xmx20m (堆的最大值) -XX:+HeapDumpOnOutOfMemoryError (让虚拟机在内存溢出异常时Dump出当前内存堆转储快照以便事后进行分析) 当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError” 会跟着进一步提示 “Java heap space”。 要解决这个区域的异常，一般的手段实现通过内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Lock）还是内存溢出（Memory Overflow）。 虚拟机栈和本地方法栈溢出由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数(设置本地方法栈大小)存在，但实际是无效的，栈容量只由-Xss参数设定。 在Java虚拟机规范中描述了两种异常 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 方法区和运行时常量池溢出参数： -XX:PermSize 方法区大小 -XX:MaxPermSize 方法区最大值 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。 方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 本机直接内存溢出DirectMemory 容量可通过 -XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值(-Xmx指定)一样。 由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO,那就可以考虑检查一下是不是这方面的原因。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第 2 章 Java内存区域与内存溢出异常]]></title>
    <url>%2F2018%2F11%2F29%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java 与 C++ 之间有堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 概述对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不需要为每一个new操作去写匹配的 delete/free 代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存。不过一旦出现内存泄漏和内存溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。 运行时数据区域Java 虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。 根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机锁管理的内存将会包括以下几个运行时数据区域 程序计数器程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个额计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程互不影响，独立存储，称这类内存区域为“线程私有”的内存。 如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError情况的区域。 Java虚拟机栈Java虚拟机栈(Java Virtual Machine Stacks)是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。 经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack)，这种分发比较粗糙，Java内存区域的划分实际上远比这复杂。 局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型（指向一了一条字节码指令的地址） 其中64位长度的logn和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果现场请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（大部分可以扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。 在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法也会抛出StackOverflowError和OutOfMemoryError异常。 Java 堆对于大多数应用来说,Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。次内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是： 所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配标量替换、配置替换 优化技术将会导致一些微妙的变化发生，所有对象在堆上也渐渐变得不是那么“绝对”了。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所有Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer， TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都任然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快地分配内存。 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们磁盘一样。在实现时，即可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中内存内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError异常。 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该与Java堆区分开来。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 直接内存直接内存(Direction Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfmemoryerror异常出现。 在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不受Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现Outofmemoryerror异常 HotSpot 虚拟机对象探秘对象的创建虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完后便可完全确定,为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边,空闲的内存放在另一边，中间放着一个指针作为分解点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump the Pointer)。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”(Free List) 除如何划分可用空间之外，还有另一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时了原来的指针来分配内存当前情况。解决这个问题有两种方案。 一种是：对分配内存空间的动作进行同步处理–实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性； 一种是：把内存分配的动作按照线程划分为不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer， TLABA）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机使用使用TLAB，可以通过 -XX:+/-UseTLAB 参数来设定。 内存分配完后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段都是数据类型所对应的零值。 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。 在上面工作都做完后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始 —&gt;方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码是否跟随invokespecial指令所决定），执行new指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对其填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分可用于存储对象自身的运行时数据，如 哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32bit和64bit，官方称为“Mark Word”。 对象头的另外一部分是类型指针，即对象指向它的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象大大小，但是从数组的元数据中却无法确定数组的大小。 HotSpot虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配在一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍数或者2倍)，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 对象的访问定位建立对象是为使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决与虚拟机实现而定的。 目前主流的访问方式有 “使用句柄” 和 “直接指针两种” 使用句柄Java堆中将会划分出一块内存来作为句柄持，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息 直接指针Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址 优势 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常客观的执行成本。 虚拟机Sun HotSpot使用的是 直接指针 进行对象访问]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库管理系统-第七章]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[需求描述与分析系统设计系统实现系统测试与维护]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库管理系统.第六章]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[数据库完整性什么是数据库完整性数据库完整性是指数据库中数据的 正确性 和 完整性 完整性约束条件的对象列级约束 -&gt; 包括队列的类型、取值范围、精度等的约束元组约束 -&gt; 指元组中各个字段之间的相互约束表级约束 -&gt; 指若干元组、关系之间的联系的约束 定义与实现完整性约束 实体完整性 在MySQL中，实体完整性是通过主键约束和候选键约束实现的 主键列必须遵循的规则 每一个表只能定义一个主键 主键的值（键值）必须能够唯一标志表中的每一行记录，不能为空 复合主键不能包含不必要的多余列 一个列名在复合主键的列表中只能出现一次 |约束方式|语句区别|区别|关键字| |--|--|--|--| |主键约束|CREATE TABLE 或 ALTER TABLE |一个表只能创建一个主键|PRIMARY KEY| |候选键约束|CREATE TABKE 或 ALTER TABLE|可以定义若干个候选键|UNIQUE| 参照完整性123REFERENCES tbl_name(index_col_name,...)[ON DELETE reference_option][ON UPDATE reference_option] RESTRICT -&gt; 限制策略 CASCADE -&gt; 级联策略 SET NULL -&gt; 置空策略 NO ACTION -&gt; 不采取实施策略 用户定义的完整性 非空约束 NOT NULL CHECK 约束1CHECK (expr) 命名完整性约束1CONSTRAINT [symbol] symbol – 指定的约束名字 只能给基于表的完整性约束指定名字，无法给基于列的完整性约束指定名字 更新完整性约束使用 ALTER TABLE语句 更新与列表或表有关的各种约束 完整性约束不能直接被修改（先修改，再增加） 使用ALTER TABLE语句，可以独立删除完整性约束，而不会删除表本身。（DROP TABLE语句删除一个表，则表中所有的完整性约束都会被自动删除） 触发器什么是触发器是用户定义在关系表上的一类由事件驱动的数据对象，也是一种保证数据完整性的方法 创建触发器使用 Create TRIGGER 语句创建触发器 12CREATE TRIGGER trigger_name trigger_time trigger_eventON tbl_name FOR EACH ROW trigger_body 删除触发器1DROP TRIGGER IF EXISTS customers_insert_trigger; 使用触发器INSERT触发器在INSERT触发器代码内，可引用一个名为NEW（不区分大小写）的虚拟表，来访问被插入的行 在BEFOR INSERT触发器中，NEW中的值可以被更新 DELETE触发器 在DELETE触发器代码内，可引用一个名为OLD（不区分大小写）的虚拟表，来访问被删除的行。 OLD的值，不能被更新 UPDATE触发器 在UPDATE触发器代码内，可引用一个名为OLD的虚拟表，来访问UPDATE语句执行前的值，也可以引用一个名为NEW的虚拟表来访问更新后的值。 完全性与访问控制用户账号管理ROOT用户 使用CREATE USER 语句创建MySQL账户1CREATE USER user [IDENTIFIED BY [PASSWORD]&apos;password&apos;] user 指定创建用户账号 格式：user_name @ ‘host_name` IDENTIFIED BY 指定用户账号对应的口令 PASSWORD 可选项，指定散列口令 删除用户1DROP USER username[,...] 栗子：1DROP USER &apos;user_name&apos;@&apos;user_localhost&apos;; 修改用户账号1RENAME USER old_user to new_name [,old_user to new_user]... 栗子：1RENAME USER &apos;zhangsan&apos;@&apos;localhost&apos; TO &apos;wangwu&apos;@&apos;localhost&apos;; 修改用户密码使用SET PASSWORD语句修改用户登录口令1SET PASSWORD [FOR USER] = &#123;PASSWORD(&apos;new_password&apos;) | &apos;encrypted password&apos;&#125; 栗子：1SET PASSWORD FOR &apos;wangwu&apos;@&apos;localhost&apos; = PASSWORD(&apos;123456&apos;); 账号权限管理使用GRANT语句为用户授权123456GRANT priv_type[(column_list)] [,priv_type [(column_list)]]... ON [object_type] priv_level TO user_specification [,user_specification]... [WITH GRANT OPTION] 栗子：1grant select(cust_id,cust_name) on mysql_test.customers to &apos;zhangsan&apos;@&apos;localhost&apos;; 授予查询，修改全部字段权限并生成一个账号赋予密码 权限可以转移栗子：1GRANT SELECT,UPDATE ON mysql_test.customers to &apos;zhou&apos;@&apos;localhost&apos; identified by &apos;123&apos; with grant option; 授予全部权限栗子：1GRANT ALL ON mysql_test.* to &apos;zhangsan&apos;@&apos;localhost&apos; with grant option; 授予用户创建用户的权限1GRANT CREATE USER on *.* to &apos;zhangsan&apos;@&apos;localhost&apos;; 使用REVOKE语句撤销用户权限12345REVOKE priv_type [(column_list)] [, priv_type[(column_list)]]... ON [object_type] priv_level FROM user [,user]... 事物与并发控制事物的概念所谓事物是用户定义的一个 数据操作序列 ，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务中的操作一般是对数据的更新操作，包括 增、删、改。 以 BEGIN TRANSACTION 语句开始 以 COMMIT（提交） 语句或 ROLLBACK（回滚） 语句结束 事物的特征 原子性 ：事物是不可分割的最小工作单位 一致性 ： 隔离性 持续性（永久性） 简称 ACID 并发操作问题 丢失更新：事物T2的提交结果会破坏T1提交的结果 不可重复读：事物T2执行更新操作，使T1无法再现前一次读取结果 读“脏”数据：事物T1修改数据后撤销，使得T2读取的数据与数据库中不一致 封锁一个锁实质上就是允许或阻止一个事务对一个数据对象的存取特权。 排它锁（X锁），用于写操作 共享锁（S锁），用于读操作 我们通常以粒度来描述封锁的数据单元的大小 粒度越细，并发性就越大，但软件复杂性和系统开销就越大。 封锁的级别 封锁的级别又称为一致性级别或隔离度 0级封锁：不重写其他为0级封锁事物的未提交的更新数据（实用价值低） 1级封锁：不允许重写未提交的更新数据。防止了丢失更新的发横 2级封锁：即不重写也不读取为提交的更新数据（防止了读脏数据） 3级封锁：不读未提交的更新数据，不写任何（包括读操作）未提交数据 死锁和活锁 活锁：先来先服务 死活：预防 一次性锁请求 锁请求排序 序列化处理 资源剥夺 数据库备份与恢复的概念 数据备份是 是指通过 导出数据 或者 复制表文件的方式来制作数据库的副本； 数据库恢复 则是当数据库出现故障或遭到破坏时，将 备份 的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。 数据的恢复是以备份为基础的，它是与备份相对应的系统维护和管理操作。 备份数据的方法 使用 SELECT INTO … OUTFILE 语句备份数据 语法：1234567SELECT * INTO OUTFILE &apos;file_name&apos; export_options | INTO DUMPFILE &apos;file_name&apos;[FIELDS [TERMINATED BY &apos;string&apos;] [[OPTIONALLY] ENCLOSED BY &apos;char&apos;] [ESCAPED BY &apos;char&apos;]][LINES TERMINATED BY &apos;string&apos;] 栗子：1234select * from mysql_test.customers into outfile &quot;/Users/panhaidong/Desktop/backupfile.txt&quot; -&gt; FIELDS TERMINATED BY &apos;,&apos; -&gt; OPTIONALLY ENCLOSED BY &quot;&quot; -&gt; LINES TERMINATED BY &quot;?&quot;; 恢复数据的方法 使用 LOAD DATA … INFILE 语句恢复数据1234567891011LOAD DATA INFILE &apos;file_name.txt&apos; INTO TABLE tbl_name [FIELDS [TERMINATED BY &apos;string&apos;] [[OPTIONALLY] ENCLOSED BY &apos;char&apos;] [ESCAPED BY &apos;char&apos;] ] [LINES [STARTINGBY &apos;string&apos;] [TERMINATED BY &apos;string&apos;] ]]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理 - 数据库编程]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第五章 - 数据库编程存储过程存储过程的基本概念存储过程 是一组为了完成某项特定功能的 SQL语句集 其实质就是一段存储在数据库中的代码 它可以由声明示的SQL语句和过程式的SQL语句组成。 可增强SQL语言的功能和灵活性 良好的封装性 高性能 可减少网络流量 可作为一种安全机制来确保数据库的安全性和数据完整性 创建存储过程DELIMITER 命令语法: 修改语句结束标识1DELIMITER $$(用户指定的标识) 使用CREATE PROCEDURE 语句创建存储过程12CREATE PROCEDURE sp_name([proc_parameter[,...]]) routine_body proc_parameter 存储过程参数列表routine_body 存储过程体 [in|out|inout]param_name type 栗子:12345DELIMITER $$CREATE PROCEDURE sp_update_sex(IN cid INT, IN csex CHAR(1))BEGIN UPDATE customers SET cust_sex = csex WHERE cust_id = cid;END$$ 存储过程体使用DELCEAR语句声明局部变量1DECLEAR var_name[...] type [DEFAULT value] 栗子:1DECLEARE cid INT(10); 只能在存储过程体的BEGIN…END语句块中声明 必须在存储过程的开头处声明 作用范围仅限于声明它的BEGIN…EBD语句块 不同于用户变量 局部变量于用户变量的区别： 局部变量声明时，在其前面没有@符号，并且它只能被声明它的BEGIN…END语句块中的语句所使用 用户变量在声明时，会在其名称前面使用@符号，同时已声明的用户变量存在于整个会话之中。 使用SET语句为局部变量赋值1SET var_name = expr[, var_name=expr]... 栗子:1SET cid = 910; 使用SELECT INTO 语句把选定列的值直接存储到局部变量中1SELECT col_name[...] INTO var_name[...] table_expr col_name-指定列名 var_name-指定要赋值的变量名 table_expr-表示SELECT语句中的FROM子句及后面的语法部分 栗子：1SELECT cust_id INTO cid customers WHERE cust_name = &apos;哇哈哈&apos;； 流程控制语句 条件判断语句 IF…THEN …ELSE语句 CASE语句 循环语句 WHILE语句 REPEAT语句 LOOP 语句 LTERATE语句 用于表示退出当前循环 使用DECLARE CURSOR语句创建游标1DECLARE cursor_name CURSOR FOR select_statement 使用 OPEN 语句打开游标1OPEN cursor_name cursor_name -&gt; 指定要打开的游标 使用FETCH…INTO语句读取数据1FETCH cursor_name INTO var_name[var_name]... cursor_name -&gt; 指定已打开的游标 var_name -&gt; 指定存放数据的变量名 使用CLOSE 语句关闭游标1CLOSE cursor_name 调用存储过程使用CALL语句调用存储过程12CALL sp_name([parameter[,...]])call sp_name[()] 栗子:1call sp_update_sex(3,&apos;m&apos;); 删除存储过程使用DROP PROCEDURE 语句删除存储过程 1DROP PROCEDURE [IF EXISTS] sp_name 存储函数什么是存储函数存储函数与存储过程一样，是由SQL语句和过程式语句组成的代码片段 存储函数 存储过程 不能拥有输出参数 可以拥有输出函数 可以直接调用存储函数 需要 CALL 语句调用存储过程 必须包含一条RETURN语句 不允许包含RETURN语句 创建存储函数使用CREATE FUNCTION语句创建存储函数 123CREATE FUNCTION sp_name([func_parameter[,...]]) RETURNS type routine_body RETURNS type 声明存储函数返回值的数据类型；type指定返回值的数据类型 12345678910111213141516DELIMITER $$CREATE FUNCTION fn_search(cid INT) RETURNS CHAR(10) DETERMINISTIC BEGIN DECLARE SEX CHAR(10); SELECT cust_sex INTO SEX FROM customers WHERE cust_id = cid; IF SEX IS NULL THEN RETURN(SELECT &apos;没有该客户&apos;); ELSE IF SEX = &apos;f&apos; THEN RETURN(SELECT &apos;女&apos;); ELSE RETURN(SELECT &apos;男&apos;); END IF ; END IF;END $$ 调用存储函数使用关键字SELECT 调用存储函数1SELECT sp_name([func_parameter[,...]]) 删除存储函数使用DROP FUNCTION语句删除存储函数1DROP FUNCTION [IF EXISTS] sp_name;]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理 - SQL与关系数据库基本操作]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第四章 - SQL与关系数据库基本操作SQL概述什么是SQL结构化查询语言 （Structured Query Language，SQL）是专门用来与数据库通信的语言，它可以帮助用户操作关系数据库 SQL的特点 SQL不是某个特定数据库供应商专用的语言 SQL简单易学 SQL强大、灵活，可以进行非常复杂和高级的数据库操作 SQL的组成 数据查询 数据定义 数据操纵 数据控制 数据定义语言（Date Definition Language，DDL） CREATE 创建数据库或数据库对象 ALTER 对数据库或数据库对象进行修改 DROP 删除数据库或数据库对象 数据库操纵语言（Date Manipulation Language，DML） SELECT 从表或视图中检索数据 INSERT 将数据插入到表或视图中 UPDATE 修改表或视图中的数据 DELETE 从表或视图中删除数据 数据控制语言（Data Control Language，DCL） GRANT 用于授予权限 REVOKE 用于收回权限 嵌入式和动态SQL规则 规定SQL语句在高级程序设计语言中使用的规范方法，以便适应较为复杂的应用 SQL调用和会话规则 SQL调用包括SQL例程和调用规则，以便提高SQL的灵活性、有效性、共享性以及使SQL具有更多的高级语言的特征； SQL会话规则可使应用程序连接到多个SQL的服务器中的某一个，并与之交互。 MySQL预备知识MySQL使用基础关系数据库管理系统（ RDBMS ） LAMP - （Linux Apache MySQL PHP/Perl/Python） WAMP - (Windows Apache MySQL PHP/Perl/Python) MySQL扩展语言要素 常量 字符串常量（也称字面值或标量值） 用单引号或双引号括起来的字符序列，分为ASCLL字符串常量和Unicode字符串常量 数值常量 整数常量 浮点数常量 十六进制常量（每对十六进制数字被转换为一个字符，其最前面有一个字母’X’或“x”） 时间日期常量（用单引号讲表示日期时间的字符串括起来而构成的） 位字段值 格式：b’value’ -&gt; 二进制值 布尔值 TURE -&gt; 1, FALSE -&gt; 0 NULL值 变量 用户变量 用户变量前常添加一个符号@，用于将其与列名区分开 系统变量 大多数系统变量应用于其他SQL语句中时，必须在系统变量前添加两个@ 运算符 算数运算符：+（加），-（减），*（乘），/（除），%（求模） 位运算符：&amp;（位于），|（位或），^（位异或），~（位取反），&gt;&gt;（位右移），&lt;&lt;（位左移） 比较运算符：=，&lt;，&gt;，&gt;=，&lt;=，&lt;&gt;，!=，&lt;=&gt; 逻辑运算符：NOT或！（逻辑非），AND或%%（逻辑与），OR或||（逻辑或），XOR（逻辑异常） 表达式 表达式是常量、变量、列名、复杂计算、运算符和函数的组合 内置函数 数学函数 聚合函数 字符串函数 日期和时间函数 加密函数 控制流程函数 格式化函数 类型转换函数 系统信息函数### 数据定义数据库模式定义####创建数据库使用 CRESTE DATABASE 或 CREATE SCHEMA 语句 语法：123CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name[DEFAULT] CHARACTER SET[=]charset_name|[DEFAULT]COLLATE[=]collation_name 栗子：12mysql&gt; create database if not exists mysql_test default character set = gbk;Query OK, 1 row affected (0.00 sec) []：表示其内容为可选项；|： 用于分割花括号中的选项 选择数据库语法：1USE DATABASE_NAME; 栗子：12mysql&gt; USE mysql_test;Database changed 修改数据库语法：12ALTER &#123;DATABASE|SCHEMA&#125; [db_name]alter_specification... 栗子：1234mysql&gt; ALTER DATABASE mysql_test -&gt; DEFAULT CHARACTER SET gb2312 -&gt; DEFAULT COLLATE gb2312_chinese_ci;Query OK, 1 row affected (0.00 sec) 删除数据库语法:1DROP &#123;DATABASE|SCHEMA&#125; [IF EXISTS] [db_name] 栗子:12mysql&gt; DROP DATABASE IF EXISTS mysql_test;Query OK, 0 rows affected, 1 warning (0.00 sec) 查看数据库语法：12SHOW &#123;DATABASES|SCHEMA&#125;[LIKE &apos;pattern&apos; | WHERE expr] LIKE 关键字用于匹配指定的数据库名称 WHERE 从句用于指定数据库名称查询范围的条件 栗子：123456789101112ysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || mysql_test || performance_schema || study || sys |+--------------------+6 rows in set (0.00 sec) 表定义创建表数据表示关系数据库中最重要的、最基本的数据对象，也是数据存储的基本单位 数据表，被定义为字段的集合，按行和列的格式来存储的，每一行代表一个记录，每一列代表记录中一个字段的取值 CREATE TABLE 语句创建表 主要由： 表创建定义（create definition） 表选项：（table options） 分区选项：（partition options） 语法：123456CREATE [TEMPORARY] TABLE tbl_name( 字段名1 数据类型 [列级完整性约束条件][默认值] [,字段名2 数据类型 [列级完整性约束条件][默认值]] [,表级完整性约束])[ENGINT=引擎类型] 栗子：在一个已有的数据库mysql_test中新建一个包含客户姓名、性别、地址、联系方式等内容的客户基本信息表，要求将客户的id号指定为该表的主键12345678910mysql&gt; CREATE TABLE customers -&gt; ( -&gt; cust_id int not null auto_increment -&gt; ,cust_name varchar(50) not null -&gt; ,cust_sex char(1) not null -&gt; ,cust_address char(50) null -&gt; ,cust_contact char(50) null -&gt; ,primary key (cust_id) -&gt; );Query OK, 0 rows affected (0.05 sec) 更新表使用ALTER TABLE语句，增加或删减列，创建或取消索引，更改原有列的数据类型，重新命名列或表，更改表的评注和表达引擎类型，为表重新创建触发器、存储过程、索引和外建等。 ADD[COLUMN]子句 示例：想数据库mysql_test的表customers中添加一列，并命名为cust_city,要求不能为null，默认值为字符串”Wuhan”,且该列位于原表cust_sex列之后。 语法:12ALTER TABLE mysql_test.customersADD COLUMN cust_city char(10) NOT NULL DEFAULT &apos;Wuhan&apos; AFTER cust_sex; 栗子：123mysql&gt; ALTER TABLE mysql_test.customers ADD COLUMN cust_city char(10) NOT NULL DEFAULT &apos;Wuhan&apos; AFTER cust_sex;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0 CHANGE[COLUMN]子句 (修改表中列的名称或数据类型) 语法：12ALTER TABLE mysql.test.customersCHANGE COLUMN cust_sex sex char(1) NULL DEFULT &apos;M&apos;; 栗子:1234mysql&gt; ALTER TABLE mysql_test.customers -&gt; CHANGE COLUMN cust_sex sex char(2) NULL DEFAULT &apos;M&apos;;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 ALTER[COLUMN]子句 修改或删除表中指定列的默认值 语法：12ALTER TABLE mysql_test.customersALTER COLUMN cust_city SET DEFAULT &apos;Beijing&apos;; 栗子：123mysql&gt; ALTER TABlE mysql_test.customers ALTER COLUMN cust_city SET DEFAULT &apos;Beijing&apos;;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 MODIFY[COLUMN]子句 只修改指定列的数据类型，不会干涉它的列名语法：12ALTER TABLE mysql_test.customersMODIFY COLUMN cust_name char(20) FIRST; 栗子:1234mysql&gt; ALTER TABLE mysql_test.customers -&gt; MODIFY COLUMN cust_name char(11) not null AFTER cust_id;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 DROP[COLUMN]子句 删除列语法： 123mysql&gt; ALTER TABLE mysql_test.customers DROP COLUMN cust_contact;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 RENAME[TO]子句 更新表名 语法:12ALTER TABLE mysql_test.customersRENAME TO my_customers; 栗子：123mysql&gt; ALTER TABLE mysql_test.customers -&gt; RENAME TO backup_customers;Query OK, 0 rows affected (0.00 sec) 删除表语法:1DROP[TEMPORANY] TABLE [IF EXISTS] tb_name [,tb_name] 栗子：12mysql&gt; DROP TABLE IF EXISTS backup_customers;Query OK, 0 rows affected (0.01 sec) 查看表语法：1SHOW [FULL] COLUMN &#123;FROM | IN&#125; tbl_name [&#123;FROM | IN&#125; db_name] [LIKE &apos;pattern&apos; | WHERE expr] 显示指定数据表的结构1&#123;DESCRIBE | DESC&#125; tbl_name [col_name | wild] 栗子： 索引定义索引是DBMS根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表 索引是提高数据文件访问效率的有效方法 索引存在的弊端： 索引是以文件的形式存储的，如果有大量的索引，索引文件可能比数据更快达到最大的文件尺寸 索引在提高查询速度的同时，会降低更新表的速度 普通索引（INDX或KEY） 唯一性索引(UNIQUE) 主键(PRIMARY KEY) 索引通常被创建成单列索引和组合索引 索引的创建：（使用CREATE INDEX语句创建）语法：12CREATE [UNIQUE] INDEX index_name ON tbl_name(index_col_name...) col_name[(length)][ASC|DESC] 栗子：123mysql&gt; CREATE INDEX index_customers -&gt; ON mysql_test.customers(cust_name(3) ASC);Query OK, 0 rows affected (0.02 sec) 组合索引栗子：12mysql&gt; CREATE INDEX index_cust -&gt; ON mysql_test.customers(cust_name, cust_id); 索引的创建：使用 CREATE TABLE 语法创建 语法项 [CONSTRAINT[symbol]] PRIMARY KEY(index_col_name, …),用于表示在创建新表的同时创建该表的主键； 语法项 {INDEX|KEY}index_name,用于表示在创建新表的同时创建该表的索引； 语法项 [CONSTRAINT[symbol]]UNIQUE[INDEX|KEY]index_name 用于表示在创建新表的同时创建该表的唯一性索引 语法项 [CONSTRAINT[symbol]] FOREIGN KEY index_name,用于表示在创建新表的同时创建该表的外建 栗子:123456789101112mysql&gt; create table seller -&gt; ( -&gt; seller_id int not null auto_increment -&gt; ,seller_name char(50) not null -&gt; ,seller_address char(50) null -&gt; ,seller_contact char(50) null -&gt; ,product_type int(5) not null -&gt; ,sales int null -&gt; ,primary key(seller_id, product_type) -&gt; ,index index_seller(sales) -&gt; );Query OK, 0 rows affected (0.02 sec) 索引的创建：使用ALTER TABLE语句创建 语法项：ADD {INDEX | KEY} index_name, 用于表示在修改表的同时为该表添加索引 语法项：ADD [CONSTRAINT [symbol]] PRIMARY KEY (index_col_name,…), 用于表示在创建新表的同时为该表添加主键 语法项：ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]index_name,用于表示在修改表的同时为该表添加唯一性索引 语法项：ADD [CONSTRAINT [symbol]] FOREIGN KEY (index_col_name,…),用于表示在创建新表的同时为该表添加外建 查看索引（SHOW INDEX）语法：1234SHOW &#123;INDEX | INDEXES | KEYS&#125;&#123;FROM | IN&#125; tbl_name[&#123;FROM | IN&#125; db_name][WHERE expr] 栗子：123456789mysql&gt; show index from seller;+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| seller | 0 | PRIMARY | 1 | seller_id | A | 0 | NULL | NULL | | BTREE | | || seller | 0 | PRIMARY | 2 | product_type | A | 0 | NULL | NULL | | BTREE | | || seller | 1 | index_seller | 1 | sales | A | 0 | NULL | NULL | YES | BTREE | | |+--------+------------+--------------+--------------+--------------+-----------+-------------+----------+--------+------+------------+---------+---------------+3 rows in set (0.00 sec) 删除索引：使用DROP INDEX语句语法：1DROP INDEX index_cust ON mysql_test.customers; 栗子：12mysql&gt; drop index index_cust ON customers;Query OK, 0 rows affected (0.02 sec) 使用ALTER TABLE语句删除 选用 DROP PRIMARY KEY 子句用于删除表中的主键，由于一个表中只有一个主键，其也是一个索引 选用DROP INDEX子句用于删除各种类型的索引 选用DROP FOREIGN KEY 子句用于删除外建 栗子:1234ALTER TABLE T_NAMEDROP PRIMARY KEY,DROP INDEX INDEX_NAME,DROP FOREIGN KEY 数据更新插入数据语法:12INSERT [INSERT] tbl_name [(col_name,...)]&#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,...),(...)... 栗子：12mysql&gt; insert into customers(cust_id, cust_name, cust_sex, cust_address, cust_contact) values (901, &apos;张三&apos;, &apos;F&apos;, &apos;北京市&apos;, &apos;朝阳区&apos;);Query OK, 1 row affected (0.02 sec) 使用INSERT … SET 语句插入部分列值数据 使用INSERT …SELECT语句插入子查询数据 删除数据使用DELETE语句删除一行或多行数据 修改数据使用UPDATE语句修改更新一个表中的数据 数据查询SELECT语句语法：123456789SELECT [ALL | DISTINCT | DISTINCTROW]select_expr [, select_expr ...]FROM tbl_name[WHERE where_condition][GROUP BY &#123;col_name|expr|position&#125;[ASC|DESC],...[WITH ROLLUP]][HAVING where_condition][ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC],...][LIMIT &#123;[offset,]row_count | row_count OFFSET offset] 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚合时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的函数 否 列的选择与指定 查询指定列 SELECT col_name1,col_name2 FROM tbl_name 查询所有列 SELECT * FROM tbl_name 定义并使用列的别名 SELECT cust_name as 地址 from customers; 替换查询结果集中的数据 123456CASE WHEN 条件1 THEN 表达式1 WHEN 条件2 THEN 表达式2....ELSE 表达式END [AS] column_alias 例:123456mysql&gt; SELECT cust_name, CASE WHEN cust_sex = &apos;m&apos; THEN &apos;男&apos; ELSE &apos;女&apos; END AS 性别 FROM customers;+-----------+--------+| cust_name | 性别 |+-----------+--------+| 哇哈哈 | 男 |+-----------+--------+ 计算列值123456mysql&gt; SELECT cust_id + 100, cust_name, cust_sex FROM customers;+---------------+-----------+----------+| cust_id + 100 | cust_name | cust_sex |+---------------+-----------+----------+| 101 | 哇哈哈 | m |+---------------+-----------+----------+ 聚合函数：通常是数据库系统中一类系统 内置函数|函数名|说明||:–|:–||COUNT|求组中项数，返回INT类型整数||MAX|求最大值||MIN|求最小值||SUM|返回表达式中所有值的和||AVG|求组中值的平均值||STD或STDDEV|返回给定表达式中所有值的标准值||VARIANC|返回给定表达式中所有值的方差||GROUP_CONTACT|返回由属于一组的列值连接组合而成的结果||BIT_AND|逻辑或||BIR_OR|逻辑与||BIT_XOR|逻辑异或| FROM子句与多表连接查询交叉连接，又称笛卡尔积语法：123SELECT * FROM tbl1 CROSS JOIN tbl2;ORSELECT * FROM tbl1, tbl2; 栗子：12mysql&gt; select * from tbl1 cross join tbl2;mysql&gt; select * from tbl1,tbl2; 内连接语法1SELECT some_columns FROM table1 INNER JOIN table2 ON some_conditions; 栗子:12 等值连接：使用运算符= 非等值连接：使用除=之外的其他比较运算符 自然连接：将一个表与他自身进行连接 外链接 左外链接：在FROM子句中使用关键字LEFT OUTER JOIN 或 LEFT JOIN 右外链接：在FROM子句中使用关键字RIGHT OUTER JOIN 或 RIGHT JOIN 简述左外连接和右外连接的区别 左外链接：也称左连接。以左表为基表，在FROM子中使用关键字“LEFT OUTER JOIN”或关键字 “LEFT JOIN” 来连接两张表。右外连接：也称右连接。以右表为基表，在FROM子句中使用关键字“RIGHT OUTER JOIN”或关键字“RIGHT JOIN”来连接两张表 WHERE子句与条件查询比较运算符 比较运算符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 &lt;=&gt; 不会返回UNKNOWN 判断范围 当查询的过滤条件被限定在值的某个范围时，可以使用关键字“BETWEEN”语法：1SELECT * FROM customers WHERE cust_id BETWEEN 1 AND 2; 使用关键字“IN”可以指定一个值的枚举表，该表中会列举所有可能的值语法：1SELECT * FRON customers WHERE cust_id in (1,2,3,4,5); 判定空值语法：1SELECT * FROM customers WHERE cust_contact is null; IN,ANY,SOME NOT IN , &lt;&gt;ALL 1SELECT * FROM tb_name WHERE col_name &#123;IN|ANY|SOME&#125; (1,2,3) 子查询-结合关键字 “EXIST”使用的子查询 子查询的结果集不为空，则返回TRUE，否则返回FALSE123SELECT * FROM customers WHERE EXISTS (SELECT * FROM customers);SELECT * FROM customers WHERE NOT EXISTS (SELECT * FROM customers); GROUP BY 子句1SELECT * FROM customers GROUP BY &#123;col_name | position&#125;[ASC | DESC],...[WITH ROLLUP] 指定在结果集中不仅包含由GROUP BY 子句分组后的数据行，还包括各分组的汇总行，以及所有分组的整行汇总行，可以得到每个分组以及每个分组汇总级别的值 HAVING 子句1HAVING WHERE_COINDITION HAVING子句 WHERE子句 过滤分组 过滤数据行 可以包含聚合函数 不可以包含聚合函数 在数据分组后进行过滤 在数据分组前过滤 ORDER BY 子句1ORDER BY &#123;col_nae expr | position&#125;[AC | DESC],... ORDER BY GROUP BY 排序产生的输出 分组行，但输出可能不是分组的排序 任意列都可以使用 只可能使用选择列或表达式 不一定需要 若聚合函数一起使用列或表达式，则必须使用 LIMIT子句使用LIMIT子句限制被SELECT语句返回的行数1LIMIT &#123;[offset,] row_count | row_count OFFSET OFFSET&#125; 栗子：123SELECT * FROM customers LIMIT 1,2;SELECT * FROM customers 2 OFFSET 1; 视图什么是视图视图是数据库中的一个对象，它是数据库管理系统提供给用户的以多种角度观察数据库中数据的一种重要机制 视图不是数据库中真实的表，而是一张虚拟表，其自身并不存在 使用视图的优点 集中分散数据 简化查询语句 重用SQL语句 保护数据安全 共享所需数据 更改数据格式创建视图123CREATEVIEW view_name[(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 指定在可更新视图上所进行的修改都需要复符合select_statement中所指定的限制条件 删除视图1drop view [if exists] view_name [,view_name]... 修改视图定义123ALTERVIEW view_name [(column_list)]AS select_statement[WITH [CASCADED | LOCAL] CHECK OPTION] 查看视图定义1SHOW CREATE VIEW view_name 更新视图数据1INSERT INTO customers_view VALUES (NULL, &apos;农夫山泉&apos;, &apos;m&apos;, &apos;北京&apos;, &apos;有点甜&apos;); 使用UPDATE语句通过视图修改基本表的数据1UPDATE customers_view SET cust_address = &apos;湖北&apos; WHERE cust_name = &apos;农夫山泉&apos;; 使用DELETE语句通过视图删除基本表的数据1DELETE FROM customers_view WHERE cust_name = &apos;农夫山泉&apos;; 查询数据视图12SELECT * FROM customers_view;`]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库管理系统-第三章-数据库设计]]></title>
    <url>%2F2018%2F08%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[数据库设计数据库设计概述数据库的生命周期 数据库分析与设计阶段 需求分析 概念设计 逻辑设计 物理设计 数据库实现与操作阶段 实现 操作与监督 修改与调整 数据库设计的目标 满足应用功能需求（存、取、删、改） 良好的性能（共享性，完整性，一致性，安全保密性） 数据库设计的内容 数据库结构设计（结构-静态的） 数据库概念结构设计 逻辑结构设计 物理结构设计 数据库行为设计（操作-动态的） 功能设计 事物设计 程序设计 数据库设计的方法 直观设计法（最原始的数据库设计方法） 规范设计法 新奥尔良设计方法：需求分析、概念结构设计、逻辑结构设计、物理结构设计 基于E-R模型的数据库设计方法 基于第三范式的设计方法，是一类结构化设计方法 计算机辅助设计法 数据库设计的过程 需求分析 结构设计 行为设计 数据库实施 加载数据库数据 调试运行应用程序 数据库运行与维护 数据设计的基本步骤需求分析目标：是了解与分析用户的信息及应用处理的需求，并将结果按一定格式整理而形成需求分析报告 该分析报告是后续 概念设计，逻辑设计，物理设计，数据库建立与维护的依据 步骤： 确定数据的范围 支持哪些应用功能 有效地利用计算机设备及数数据库系统的潜在能力 提高数据的应变能力 避免应用过程中对数据库做太多或太大的修改 延长数据库的生命周期 分析数据应用过程-结果是数据库设计结构设计的重要依据 用到哪些数据 数据使用的顺序 对数据作何处理和处理的策略以及结果 收集与分析数据 数据分类表-用于数据的总体描述（静态的结构） 数据元素表-值通常意义下的数据项或属性（静态结构） 任务分类表-一个任务指为完成某个特定处理功能的相对独立的操作序列（动态结构） 数据特征操作表-用以描述任务和数据之间的关系，它包括不同任务对数据执行不同操作的评率（动态） 数据约束 数据的安全保密性 数据的完整性 响应时间 数据恢复 编写需求分析报告 数据的应用功能目标 标明不同用户视图范围 应用处理过程需求说明，包括，数据流程图；任务分类表；数据操作特征表；操作过程说明书。 数据字典，是数据系统中存储三级结构定义的数据库，通常指的是数据库系统中各类数据详细描述的集合。通常包括数据分类表、数据元素表和各类原始资料 数据量 数据约束 概念结构设计 概念模型（自顶向下） 顶层设计 独立于任何软件与硬件 主要目标：最大限度的满足应用需求 逻辑结构设计 层次模型 网状模型 关系模型 面向对象模型 概念设计 –&gt; 模型转换 –&gt; 子模式设计 / 应用程序设计说明 –&gt; 设计评价(检验) –&gt; 物理设计 物理设计具体任务主要是确定数据在存储设备上的 存储结构 及 存取方法 ，因DBMS的不同还可能包括 建立索引 和 聚集，以及 物理块的大小、 缓冲区个数和大小、数据压缩的选择 数据库实施 加载数据：收集、分类、整理校验、输入等 应用程序设计：具有较高的稳定性，并具有试运行的数据基础，也具备了应用程序编制与调试的必要条件。这样编写的应用程序具有较高的稳定性和实用性 数据库试运行 有利于工作人员掌握并熟悉系统 有利于正式运行时避免人为的的操作不当等损害 数据库运行与维护需求分析– 结构设计 / 行为分析 – 数据实施 – 数据库运行与维护 保证数据库的正常运行 系统维护中最困难的工作是 数据库重组与重构 关系数据库设计方法关系数据库设计过程与各级模式应用要求 – 概念模式（E-R图） – 逻辑模式 –内模式 概念结构设计方法E-R图的表示方法1：1 的联系1：N 的联系M：N 的联系单个实体型内的一对多联系 局部信息结构设计： 确定局部范围：局部范围主要依据需求分析报告中标明的用户视图范围来确定。往往与子模式范围相对应 选择实体：数据分类表是选择实体的直接依据，实体选择最大困难时如何区别 实体与属性 选择实体的关键字属性：实体的存在依赖于其 关键字 的存在 确定实体间的联系：数据间的联系必须在概念设计时确定 确定实体的属性：属性分为标识属性和说明属性 全局信息结构设计： 逻辑结构设计方法 将E-R图转化为关系模式 一个实体型转换为一个关系模式，实体的属性作为关系的属性，实体的码作为关系的码 一个一对一联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并 一个一对多联系可以转换为一个独立的关系模式，也可以与N端对应的关系模式合并 一个对多对联系转换为一个关系模式 三个或以上实体间的一个多元联系可以转换为一个关系模式 具有相同码的关系模式可合并 对关系数据模型进行优化 数据逻辑设计的结果，不是唯一的 进一步提高数据库应用系统的性能 根据需要适当地修改、调整数据模型的结构 数据模型的优化 确定各属性间的函数依赖关系 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系 判断每个关系模式的范式，根据实际需要确定最合适的范式 按照需求分析阶段得到的处理要求，分析这些模式对于这样的应用环境是否合适，确定是否要对某些模式进行合并或分解 对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率 设计面向用户的外模式（子模式） 可以通过试图机制在设计使用户视图时，重新定义某些属性的别名，使其更符合用户的习惯，以方便使用 可以对不同级别的用户定义不同的视图，以保证系统的安全性 简化用户对系统的使用 物理设计 建立索引（逻辑连接） 静态建立索引 动态建立索引 建立聚集（物理聚集） 聚集是将相关数据集中存放 的物理存储技术 数据聚集结构的一种有效方式是 块结构方式 数据聚集可在 一个或多个关系上建立]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第二章 · 关系数据库]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第二章 · 关系数据库 关系数据库概述 关系数据模型 关系数据库的规范化理论（范式） 2.1 关系数据库概述关系数据库的产生历史 1970年 IBM的E.F.Codd提出了关系模型，奠定了关系数据库的理论基础 20世纪70年代末 关系方法理论研究和软件系统的研制取得了重大突破 1981年 出现了比较成熟的关系数据库管理技术，证实了关系数据库的优点 高级的非过程语言接口、较好的数据独立性 20世纪80年代后 网状模型和层次模型与低层实现的结合紧密，关系模型具有坚实理论基础，称成为主流数据模型 2.2 关系数据模型组成要素 关系数据结构 关系操作集合 关系完整性约束 关系数据结构 表（Table）是一个二维的数据结构，由表名、列、若干行数据组成 关系（Relation）一个关系逻辑上对应一张二维表，可以为每个关系去一个名称进行表示 基本关系（基本关系表、基表） 查询表 视图表 列（Column）也称字段（Field）或属性（Attribute） 表名必须唯一 字段名必须唯一 不同表中可以出现相同的字段名 属性（Attribute）= 列 行（Row）也成为 元组（Tuple） 或 记录（Record）。表中的数据按行存储 分量（Component）= 具体的数据项 元组（行）中的一个属性值，称为分量 码或键（Key） 属性（或属性组）的值 都能用来 唯一表示该关系的元组，则称这些属性（或属性组）为该关系的码或键 超码或超键（Super Key） 在码中去除某个属性，它仍然是这个关系的码 候选码或候选键（Candidate Key） 在码中不能从中移去任何一个属性，否则它就不再是这个关系的码或键。候选码或候选键是这个关系的最小超码或超键 主属性（Primary Attribute）或非主属性（NonPrimanry Attribute） 包含在任何一个候选码中的属性称为主属性或码属性 主码或主键（Primary Key）主观意愿指定的 在若干个候选码中指定一个唯一标识关系的元组（行） 全码或全键（All Key） 一个关系模式的所有属性集合是这个关系的主码或主键，这样主码或主键称为全码或全键 外码或外键（Foreign Key） 某个属性（或属性组）不是这个关系的主码或候选码，而是另一个关系的主码 域（Domain）表示属性的取值范围 数据类型（Date Type） 每个列都有相应的数据类型，它用于限制（或容许）该列中存储的数据 关系模式（Relation Schema） 关系模型是型（type），关系是值（value），即关系模式是对关系的描述 关系模式是静态的、稳定的 关系是动态的，随时间不断变化的 关系数据库（Relation Database） 所有关系的集合，构成了一个关系数据库 以关系的集合，构成一个关系数据库。 以关系模型作为数据的逻辑模型，并采用关系作为数据的组织方式的一类数据库，其数据操作建立在关系代数的基础上 关系数据库对关系的限定/要求： 每个属性都是不可分解的（不允许表中有表） 每个关系仅仅有一种关系模式 每一个关系模式中的属性必须命名，属性名不同 同一个关系中不允许出现候选码或候选键值完全相同的元组 在关系中元组的顺序（即行序）是无关紧要的，可以任意交换 在关系中属性的顺序（即列序）是无关紧要的，可以任意交换 基本的关系操作 查询（Query） 选择 投影 并 差 笛卡尔积 由上述的操作引出 连接、除、交 插入（Insert） 修改（Delete） 删除（Update） 特点：集合操作方法（一次一集合） 关系数据语言 关系代数语言 SQL 关系演算语言 元组关系演算 域关系演算 运算符任何一种操作都包含三大要素： 操作对象 操作符 集合运算符 关系运算符 比较操作符 逻辑操作符 操作结果 传统的集合运算符 并（UNION） R3 = R1 ∪ R2 两个关系必须有相同的属性个数 差（DIFFERENCE）R3 = R1 - R2 两个关系必须有相同的属性个数 交（INTERSECTION）R3 = R1 ∩ R2 两个关系必须有相同的属性个数 笛卡尔积（CARTESIAN PRODUCT）R3 = R1 × R3 两个关系可以由不相同的属性个数 专门的关系运算选择（SELECT）：Of(R) SELECT 关系名 WHERE 条件由常数、属性名或列名、比较操作符（&gt;、&lt;、=、≥、≤、≠）及逻辑操作符（）组成的条件表达式 投影（PROJECTION）πA（R） PROJECTION 关系名（属性名1，属性名2，…，属性名n） 连接（JOIN） JOIN 关系名1 AND 关系名2 WHERE 条件1、笛卡尔积2、只留属性值相同3、去掉重复列 除（DIVISION）：R ÷ S 1、投影2、笛卡尔积3、全部相同4、得出除表 完整性约束数据库的完整性是值数据库中数据的 正确性、相容性、一致性 分类： 实体完整性约束（Entity Integrity Constraint）主码的组成不能为空，主属性不能是空值NULL 参照完整性约束（Referential Integrity Constraint）定义外码和主码之间的引用规则，要么外码等于主码中某个元组的主码值，要么Null值 用户定义完整性约束（User-defined Integrity Constraint）域完整性约束（针对某一应用环境的完整性约束），其他 执行插入操作的检验 检查实体完整性约束 检查参照完整性约束 检查用户定义完整性约束 执行删除操作 (是否被引用) 一般只需要对被参照关系检查参照完整性约束 执行更新操作上述两种情况的综合 关系数据库的规范化理论 关系模式中可能存在的冗余和异常问题 函数依赖于关键字 范式于关系规范化过程 关系模式中可能存在的冗余和异常问题数据冗余：指同一数据被反复存储的情况 更新异常：数据冗余造成的 插入异常： 删除异常： 函数依赖于关键字什么是函数？ f: a –&gt; B, y=f(x) 分类： 完全函数规范设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的任何真子集X丿，都有 X丿 依赖 Y，则称Y完全函数依赖于X例：X 表 A,B属性 组成 R，并且 X 依赖 Y，且对X中的任何真子集 部分函数依赖设R为任意给定关系，X、Y为其属性值，若 X 依赖 Y，且对X中的存在一个真子集X丿，满足 X丿 依赖 Y，则称Y部分函数依赖于X 传递函数依赖设R为任一给定关系， X,Y,Z为其不同属性子集，若 X 依赖 Y， Y 不依赖 X， Y 依赖 Z， 则有 X 依赖 Z，称为Z传递函数依赖于X 关键字设R为任一给定关系，U为其所含的全部属性集合 X为U的子集，若有完全函数以为 X依赖U，则X为R的一个候选关键字 范式与关系规范化过程一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合，这个过程就叫 规范化（Normalization） 第一范式1NF设R为任意给定关系，若果R中每个列与行的交点处的取值都是不可再分的基本元素，则R为第一范式 第二范式设R为任意给定关系，若R为1NF，且其所有非主属性都完全含糊依赖于候选关键字，则R为第二范式 第三范式设R为任意给定关系，若R为2NF，且其每一个非主属性都不传递函数依赖于候选关键字，则R为第三范式 第三范式的改进形式BCNF设R为任一给定关系，X,Y为其属性集，F为函数依赖集，若R为3NF，且其F中所有函数依赖 X -&gt; Y(Y不属于X)中的X必包含候选关键字，则R为BCNF。]]></content>
      <categories>
        <category>考试</category>
        <category>数据库系统原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[检索数据]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[介绍如何使用SELECT语句从表中检索一个或多个数据列。 1、SELECT语句&nbsp;&nbsp;&nbsp;&nbsp;SQL语句由简单的英语单词构成。这些英语单词称为关键字，每个SQL语句都是用一个或多个关键字构成的。 2、检索单个列输入 SELECT prod_name FROM products;分析: 利用SELECT语句从product表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。 SQL语句和大小写 SQL语句不区分大小写，因此SELECT与select是相同的。许多开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。使用空格 在处理SQL语句时，其中所有空格都被忽略。SQL语句可以在一行上给出，也可以分成许多行。多行易于调试。 3、检索多个列&nbsp;&nbsp;&nbsp;&nbsp;要想从一个表中检索多个列，使用相同的SELECT语句。唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须有逗号分隔。 当心逗号 在选择多个列时，一定要在列名之间加上逗号，但最后一个列名不加。 例：SELECT prod_id, prod_name, prod_price FROM products; 4、检索所有列&nbsp;&nbsp;&nbsp;&nbsp;除了指定所需的列外，SELECT语句还可以检索所有的列而不必逐个列出它们。这可以通过在实际列名的位置使用星号（）通配符来达到。例：`SELECT FROM products;` 使用通配符 一般，除非你确实需要表中的每个列，否则最好别使用*通配符。检索不需要的列通常会降低检索和应用程序的性能。 5、检索不同的行&nbsp;&nbsp;&nbsp;&nbsp;SELECT返回所有匹配的行。但是，如果你不想要每个值都出现，怎么办? 使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。例：SELECT DISTINCT vend_id FROM products; 不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price, 除非指定的两个列都不同，否则所有行都将被检索出来。 6、限制结果&nbsp;&nbsp;&nbsp;&nbsp;SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句。 例: SELECT prod_name FROM products LIMIT 5;次语句使用SELECT语句检索单个列。 LIMIT 5指示MySQL返回不多于5行。 为了得出下一个5行，可指定要检索的开始行和行数。 例：SELECT prod_name FROM products LIMIT 5,5; 分析：LIMIT 5,5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数 行0 检索出来的第一行为行0而不是行1。因此， LIMIT 1,1将检索出第二行而不是第一行。在行数不够时 LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行，MySQL将只返回的那么多行。MySQL 5的LIMIT语法 LIMIT 3,4的含义是从行3开始的4行，这容易把人搞糊涂，MySQL 5支持LIMIT的另一种替代语法。LIMIT 4 OFFSET 3意从行3开始取4行，就像LIMIT 3,4一行。 7、使用完全限定的表名例：SELECT products.prod_name FROM products; 表名也是可以完全限定的 例：SELECT products.prod_name FROM crashcourse.products;]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用MySQL]]></title>
    <url>%2F2018%2F08%2F02%2F%E4%BD%BF%E7%94%A8MySQL%2F</url>
    <content type="text"><![CDATA[1、连接为了连接到MySQL，需要以下信息： 主机名（计算机名）– 如果连接到本地MySQL服务器，为localhost； 端口（如果使用默认端口3306之外的端口） 一个合法的用户名； 用户口令 示例：1mysql -u ben -p -h myserver -P 9999 2、选择数据库在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作之前，需要选择一个数据库。为此，可使用 USE 关键字 关键字（key word）作为MySQL语言组成部分的一个保留字。绝不要用关键字命名一个表或列 示例：1USE crashcourse; 3、了解数据库和表&nbsp;&nbsp;&nbsp;&nbsp;数据库、表、列、用户、权限等的信息被存储在数据库和表中。如果不知道可以使用的数据库名时，可以使用 MySQL的 SHOW 命令来显示这些信息。 示例：1SHOW DATABASES; 为了获取一个数据库内的表的列表，使用 SHOW TABLES;示例：1SHOW TABLES; SHOW 也可以用来显示表列 SHOW COLUMNS FROM customers;DESCRIBE 语句 MySQL支持功DESCRIBE作为SHOW COLUMNS FROM的一种快捷方式。换句话说，DESCRIBE customers; 是SHOW COLUMNS FROM customers;的一种快捷方式。 所支持的其他 SHOW 语句还有： SHOW STATUS; 用于显示广泛的服务器状态信息； SHOW CREATE DATABASE 和 SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW ERRORS 和 SHOW WARNINGS 用来显示服务错误或警告消息。]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[了解SQL]]></title>
    <url>%2F2018%2F08%2F01%2F%E4%BA%86%E8%A7%A3SQL%2F</url>
    <content type="text"><![CDATA[1、数据库基础什么是数据库&nbsp;&nbsp;&nbsp;&nbsp;数据库是一个以某种有组织的方式存储的数据集合。理解数据库的一种最简单的办法是将其想象为一个文件柜。此文件柜是一个存放数据的物理位置，不管数据是什么以及如何组织的。 数据库软件应称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操纵的容器。 表&nbsp;&nbsp;&nbsp;&nbsp;在你将资料放入自己id文件柜时，并不是随便将它们扔进某个抽屉就完事了，而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 &nbsp;&nbsp;&nbsp;&nbsp;在数据库领域中，这种文件成为表。表示一种结构化的文件，可用来存储某种特定类型的数据。 表（table）某总特定类型数据的结构化清单&nbsp;&nbsp;&nbsp;&nbsp;存储在表中的数据是一种类型的数据或一个清单。决不应该将顾客的清单与订单的清单存储在同一个数据库表中。&nbsp;&nbsp;&nbsp;&nbsp;数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的。 列和数据类型表由列组成。列中存储着表中某部分信息 列（column）表中的一个字段。所有的表都是由一个或多个列组成的。 &nbsp;&nbsp;&nbsp;&nbsp;数据库中每个列都有相应的数据类型。数据类型定义列可以存储的数据种类。 数据类型（datatype）所容许的数据的类型。每个列表都有相应的数据类型，它限制（或容许）该列中存储的数据 行&nbsp;&nbsp;&nbsp;&nbsp;表中的数据是按行存储的，所保存的每个记录存储在自己的行内。 行（row）表中的一个记录。 主键&nbsp;&nbsp;&nbsp;&nbsp;表中的每一行都应该有可以唯一表示自己的一列。 主键（primary key）一列，其值能够唯一区分表中的每个行。 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许NULL值） 主键的最好的习惯： 不更新主键列中的值； 不重用主键列的值； 不再主键列中使用可能会更改的值。 什么是SQL&nbsp;&nbsp;&nbsp;&nbsp;SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库通信的语言。]]></content>
      <categories>
        <category>MySQL必知必会</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习MarkDown语法 - 基本语法]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%AD%A6%E4%B9%A0MarkDown%E8%AF%AD%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、标题在想要设置为标题的文字前面加#来表示一个#是一级标题, 两个#是二级标题,以此类推。支持六级标题。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下: 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 二、字体 加粗 要把加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例:1234*我是斜体***这是加粗的文字*****我是斜体加粗***~~我是删除线~~ 效果如下: 我是斜体 这是加粗的文字 我是斜体加粗 我是删除线 三、引用在引用的文字前面加&gt;即可。示例:123&gt;这是引用的内容&gt;&gt;两个引用&gt;&gt;&gt;&gt;&gt;五个引用 效果如下: 这是引用的内容 两个引用 五个引用 四、分割线三个或三个以上的-或者*都可以.示例:1234-------******* 效果如下: 五、图片语法:1![图片alt](图片地址 &quot;图片title&quot;) 示例:1![blockchain](https://niyiwei.github.io/uploads/avatar.jpeg &quot;你以为&quot;) 效果如下: 六、超链接语法:1[超链接名](超链接地址 &quot;超链接title&quot;) 示例:12[你以为](https://niyiwei.github.io &quot;你以为&quot;)[京东](https://jd.com &quot;京东商城&quot;) 效果如下: 你以为 京东 七、列表 无序列表 语法:无序列表用 -+* 任何一种都可以123- 列表一+ 列表二* 列表三 效果如下: 列表一 列表二 列表三 有序列表语法:数字加点123451 .列表内容2 .列表内容3 .列表内容注意: 序号跟内容之间要有空格 效果如下: 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格 一级无序列表内容 二级无序列表内容 二级无序 二级无序 一级无序列表内容 二级无序 二级无序 一级有序列表 二级有序 二级有序 无序无序 一级有序列表 二级无序 二级无序 八、表格语法:1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 效果如下: 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间用一个反引号包起来1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行123（```） 代码。。。（```）]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
